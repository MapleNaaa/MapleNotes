# 生产者-消费者问题

只有缓冲区不满时，生产者才会把产品放入缓冲区，否则等待。
只有缓冲取不空时，消费者才能取产品，否则等待。
缓冲区为临界资源，必须互斥访问。

相邻P操作不可以交换顺序。
相邻V操作可以交换顺序。

## 步骤

①有几类进程就有几个函数
②在每个函数内部用中文描述进程动作
	只做一次不加while，不断重复加while
③分析每一动作之前是否需要P什么
	只要有P必有V。每写一个P，就要安排V
④写完所有PV后，再去定义信号量，定义完后再思考初值为多少
⑤检查多个连续P是否可能出现死锁
⑥看题干是否符合

## 例题

1.系统中有一组生产者和一组消费者，生产者每次生产一个产品放入缓冲区，消费者每次从缓冲区取出一个产品并使用。
生产者和消费者共享一个初始为空、大小为n的缓冲区。

```c
semaphore mutex=1; //互斥信号量，表示互斥访问缓冲区
semaphore empty=n; //同步信号量，表示空闲缓冲区的数量
semaphore full=0; //同步信号量，表示缓冲区的产品数量

producer(){
    while(1){
        生产一个产品;
        P(empty);	//消耗一个空闲缓冲区
        P(mutex);
        把产品放入缓冲区;
        V(mutex);
        V(full);	//增加一个产品
    }
}

consumer(){
    while(1){
        P(full);	//消耗一个产品
        P(mutex);
        从缓冲区取出一个产品;
        V(mutex);
        V(empty);	//增加一个空闲缓冲区
        使用一个产品;
    }
}
```

2.某工厂有两个生产车间和一个装配车间，两个生产车间分别生产A、B两种零件，装配车间的任务是把A、B两种零件组装成产品。两个生产车间每生产一个零件后，都要分别把它们送到装配车间的货架F1、F2上。F1存放零件A，F2存放零件B，F1和F2的容量均可存放10个零件。装配工人每次从货架上取一个零件A和一个零件B后组装成产品。请用P、V操作进行正确管理。

```c
semaphore mutex1=1;	//F1互斥访问
semaphore mutex2=1;	//F2互斥访问
semaphore empty1=10;//F1空闲区域
semaphore empty2=10;//F2空闲区域
semaphore full1=0;	//F1上A的数量
semaphore full2=0;	//F2上B的数量

车间1(){								车间2(){
    while(1){							while(1){
       生产A;								  生产B;
       P(empty1);						    P(empty2);
       P(mutex1);							P(mutex2);
       把A放到F1上;							 把B放到F2上;
       V(mutex1);							V(mutex2);
       V(full1);							V(full2);
    }									}
}									}

装配(){
    while(1){
        P(full1);
        P(mutex1);
        从F1拿A;
        V(mutex1);
        V(empty1);
        
        P(full2);
        P(mutex2);
        从F2拿B;
        V(mutex2);
        V(empty2);
        装配
    }
}
```

3.某寺庙有小和尚、老和尚若干。有一水缸，由小和尚提水入缸供老和尚饮用。
	水缸可容10桶水，水取自同一井中。水井径窄，每次只能容一个桶取水。水桶总数为3个。每次入缸取水仅为1桶水，且不可同时进行试给出有关从缸取水、入水的算法描述。

```c
semaphore mutex1=1;	//对井互斥访问
semaphore mutex2=1;	//对缸互斥访问
semaphore A=3;		//空闲水桶数
semaphore empty=10; //缸中空闲数
semaphore full=0;	//缸中已存水数

取水(){
    while(1){
        P(full);	//检查是否有水
        P(A);
        拿桶;
        P(mutex2);	//对缸互斥访问
        老和尚去缸里打水;
        V(mutex2);
        V(empty);
        喝水;
        还桶;
        V(A);
    }
}  

入水(){
    while(1){
        P(empty);
        P(A);
        拿桶;
        P(mutex1);
        小和尚去井打水;
        V(mutex1);
        P(mutex2);
        桶水入缸;
        V(mutex2);
        V(full);
        还桶;
        V(A);
    }
}
```

**<font color='red'>4.</font>**系统中有多个生产者进程和多个消费者进程，共享一个能存放1000件产品的环形缓冲区(初始为空)。当缓冲区未满时，生产者进程可以放入其生产的一件产品，否则等待。当缓冲区未空时，消费者进程可以从缓冲区取走一件产品，否则等待。要求一个消费者进程从缓冲区连续取出10件产品后，其他消费者进程才可以取产品。请使用信号量P，V操作实现进程间的互斥与同步，要求写出完整的过程，并说明所用信号量的含义和初值。

**问题：如何连续取10件产品** ？

```c
semaphore mutex1=1; 	//互斥访问缓冲区
semaphore mutex2=1;		//保证连续取10个
semaphore full=0;		//缓冲区已存产品数
semaphore empty=1000; 	//缓冲区空闲数
int i;

生产者(){
    while(1){
        生成产品;
        P(empty);
        P(mutex1);
        放入产品;
        V(mutex1);
        V(full);
    }
}

消费者(){
    while(1){
        P(mutex2);
        for(int i=0;i<10;i++){	//采用for循环，且循环过程一气呵成
            P(full);
            P(mutex1);
        	取1个产品;
            V(mutex1);
        	V(empty);
        }
        V(mutex2);
    }
}
```

**<font color='red'>5.</font>**设P,Q,R共享一个缓冲区，P、Q构成一对生产者-消费者，R既为生产者又为消费者（若缓冲区为空，则可以执行生产者的功能，若缓冲区不空，则执行消费者的功能）。使用P,V操作实现其同步

```c
semaphore mutex1=1;	//对缓冲区互斥访问
semaphore mutex2=1;	//对flag变量互斥访问
semaphore full=0;	//缓冲区已有数量
semaphore empty=1;	//缓冲区空白
int flag=0;			//是否为空
```

<img src="E:\图片\图床\image-20241015082305352.png" alt="image-20241015082305352" style="zoom:80%;" />



# 多生产者-多消费者问题

桌子上有一只盘子，每次只能向其中放入一个水果。
爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。
只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。
仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。

当缓冲区仅有一个空闲有可能不设置互斥信号量mutex，不为一个时候不可以。

<img src="E:\图片\图床\image-20241013075634046.png" alt="image-20241013075634046" style="zoom: 67%;" />

# 理发师问题

![image-20241013142859560](E:\图片\图床\image-20241013142859560.png)

​	**<font color='red'>1.</font>**理发店理有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉，一个顾客到来时，顾客必须叫醒理发师，如果理发师正在理发时又有顾客来1到，则如果有空椅子可坐，就坐下来等待，否则就离开。

```c
int waiting=0; 		//等待顾客数
semaphore mutex=1;	//对waiting互斥访问
semaphore service=0;//提供服务
semaphore customer=0;//是否睡觉
```

![image-20241014151748553](E:\图片\图床\image-20241014151748553.png)

​		**2.**银行提供1个服务窗口和10个供顾客等待的座位，顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号	取号机每次仅允许一位顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。
​		顾客和营业员的活动过程描述如下:
<img src="E:\图片\图床\image-20241013144841595.png" alt="image-20241013144841595" style="zoom: 67%;" />

```c
int waiting=0; 		//等待顾客数
semaphore mutex=1;	//对waiting互斥访问
semaphore service=0;//提供服务
```

![image-20241014152040854](E:\图片\图床\image-20241014152040854.png)

**<font color='red'>3.</font>**面包师有很多面包，由n个销售人员推销。每个顾客进店后取一个号并且等待叫号，当一个销售人员空闲下来时，就叫下一个号。试设计一个使销售人员和顾客同步的算法。

<font color='red'>**顾客和销售人员都有编号**</font>。

```c
semaphore Sm=0;	//销售员唤醒正在等待的顾客
semaphore Cs=0;	//有几个已取号的顾客

Customer_i(){
    取号;
	V(Cs);
    等待被叫号;
    P(Sm);
    被服务;
}

Dealer(){
    while(1){
        P(Cs);
        叫号;
        V(Sm);
        提供服务;
    }
}
```



# 吸烟者问题

假设一个系统有**三个抽烟者进程和一个供应者进程**。
每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。
三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。
供应者进程无限地提供三种材料，供应者每次将**两种材料放桌子上**，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并**给供应者进程一个信号告诉完成了**，供应者就会放另外两种材料再桌上，这个过程一直重复(**让三个抽烟者轮流地抽烟**)

 <font color='red'>**将纸+胶水看作组合一**</font>。
因为只有一个临界资源，因此不必要设置互斥访问量。
<font color='red'>**设置int i=(i+1)%3来实现轮流吸烟**</font>。

![image-20241014152220838](E:\图片\图床\image-20241014152220838.png) 

**<font color='red'>1.</font>** 三个进程P1、P2、P3互斥使用一个包含N个单元的缓冲区。P1每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中；P2每次用getodd0)从该缓冲区中取出一个奇数并用countodd()统计奇数个数；P3每次用geteven()从该缓冲区中取出一个并用counteven0)统计偶数个数。请用信号量实现这三个进程的同步与互斥，并说明所定义信号量的含义

问题：<font color='red'>**使用x存储数，并判断奇数与偶数存在个数**</font>。

```c
semaphore mutex=1;	//互斥访问缓冲区
semaphore odd=0;	//已有偶数
semaphore even=0;	//已有奇数
semaphore empty=n;	//空闲数
```

![image-20241015084858523](E:\图片\图床\image-20241015084858523.png)

# 读者-写者问题

​	有读者和写者两组并发进程，共享一个文件。
​	当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。
​	因此要求:
​		①允许多个读者可以同时对文件执行读操作:
​		②只允许一个写者往文件中写信息:
​		③任一写者在完成写操作之前不允许其他读者或写者工作;
​		④写者执行写操作前，应让已有的读者和写者全部退出。

<font color='red'>**count实现读者的访问**</font>【<font color='red'>**count也需要互斥访问**</font>】 
<font color='red'>**w防止写饥饿**</font> 

**<font color='blue'>可能饥饿，读优先</font>**	  

```c
semaphore lock=1;	//互斥访问文件
int count=0;		//当前读进程
semaphore mutex=1;	//对count互斥访问
```

​			 	<img src="E:\图片\图床\image-20241014152730840.png" alt="image-20241014152730840" style="zoom: 80%;" />

<font color='blue'>**不会饥饿，先来先服务**</font> 

```c
semaphore lock=1;	//实现对共享文件的互斥访问
int count=0;		//当前有几个读者访问文件
semaphore mutex=1;	//对count进行互斥访问
semaphore queue=1;	//用于实现先来先用
```

​	     		<img src="E:\图片\图床\image-20241014153027656.png" alt="image-20241014153027656" style="zoom:80%;" />

<font color='blue'>**不会饥饿，写优先**</font> 

```c
semaphore readlock=1;	//给读者上锁
semaphore writelock=1;	//给写者上锁
semaphore rmutex=1;		//对readCount互斥访问
semaphore wmutex=1;		//对writeCount互斥访问
int readCount=0;		//读者数量
int writeCount=0;		//写者数量
```

![image-20241014153404917](E:\图片\图床\image-20241014153404917.png)

## 例题

**<font color='red'>1.</font>**某进程中有三个并发执行的线程thread1，thread2，thread3，其伪代码为
<img src="E:\图片\图床\image-20241014095524670.png" alt="image-20241014095524670" style="zoom:50%;" />   <font color='red'>**如何确认互斥关系？**</font>	<img src="E:\图片\图床\image-20241014095834168.png" alt="image-20241014095834168" style="zoom:50%;" />

只有全局变量才需要互斥，局部变量不需要互斥

**<font color='red'>读读不需要互斥</font>**。
**<font color='red'>读写需要互斥</font>**。
**<font color='red'>写写需要互斥</font>**。

```c
semaphore mutex1=1;	//对thread1和thread3中的y互斥访问
semaphore mutex2=1;	//对thread2和thread3中的y互斥访问
semaphore mutex3=1;	//对thread2和thread3中的z互斥访问
```

<img src="E:\图片\图床\image-20241014101908518.png" alt="image-20241014101908518" style="zoom:80%;" />

**<font color='red'>2.</font>**在一个仓库中可以存放A和B两种产品，要求
	1)每次只能存入一种产品。
	2)A产品数量-B产品数量<M。
	3)B产品数量-A产品数量<N。
其中，M、N是正整数，试用P操作、V操作描述产品A与产品B的入库过程

<font color='red'>**要求2,3如何实现**</font>？	【A产品最多比B多M-1个，B产品最多比A多N-1个】

```c
semaphore mutex=1;	//互斥访问仓库
semaphore A=M-1;	//A产品最多比B多M-1个
semaphore B=N-1;	//B产品最多比A多N-1个
```

![image-20241014160031717](E:\图片\图床\image-20241014160031717.png)

<font color='red'>**3.**</font>设自行车生产线上有一只箱子，其中有N个位置(N>3)，每个位置可存放一个车架或一个车轮;又设有3
个工人，其活动分别如下，试分别用信号量与PV 操作实现三个工人的合作，要求解中不含死锁。

<font color='red'>**可能发生死锁的情况**</font>：箱子中全为车轮/车架【因此需要限制车架/车轮的最大值】

```c
semaphore mutex=1;		//互斥访问箱子
semaphore frame=0;		//已有车架数
semaphore wheel=0;		//已有车轮数
semaphore frameMax=N-2;	//最多放多少车架
semaphore wheelMax=N-1;	//最多放多少车轮
```

![image-20241015080046967](E:\图片\图床\image-20241015080046967.png)

**<font color='red'>3.</font>**有桥如图所示。车流方向如箭头所示。回答如下问题:
	1)假设该桥上每次只能有一辆车行驶，试用信号灯的P、V操作实现交通管理
	2)假设该桥上不允许两车交会，但允许同方向多个车一次通过(即桥上可有多个同方向行驶的车)。
试用信号灯的P、V操作实现桥上交通管理。
<img src="E:\图片\图床\image-20241014171905994.png" alt="image-20241014171905994" style="zoom:50%;" /> 

```c
semaphore bridge=1;	//对桥互斥访问
int count1=0;		//从南到北的车
int count2=0;		//从北到南的车
semaphore mutex1=1;	//对count1互斥访问
semaphore mutex2=1;	//对count2互斥访问
```

![image-20241014172959888](E:\图片\图床\image-20241014172959888.png)

4.假设有一个个录像户有1、2、3三种不同的录像片可由观众选择放映，录像厅的放映规则为:
(1)任一时刻最多只能放映一种录像片，正在放映的录像片是自动循环放映的，最后一个观众离开时结束当前录像片的放映
(2)选择当前正在放映的录像片的观众可立即进入，允许同时有多位选择同一种录像片的观众同时观看，同时观看的观众数量不受限制;
(3)等待观看其他录像片的观众按到达顺序排队，当一种新的录像片开始放映时，所有等待观看该录像片的观众可依次序进入录像厅同时观看。用一个进程代表一个观众，

![image-20241015101113083](E:\图片\图床\image-20241015101113083.png)

# 哲学家进餐问题

①**限制申请资源顺序：**要求奇数哲学加先拿左筷子，再拿右筷子。偶数哲学家相反。【不通用】
②**限制并发进程数**：规定时间内只能有一个哲学家进餐【不通用】
③**一次性申请所有资源：** 【通用】

有 n(n>3)名哲学家围坐在一张圆桌边，每名哲学家交替地就餐和思考。在圆桌中心有 m(m>1)个碗，每两名哲学家之间有一根筷子。每名哲学家必须取到一个碗和两侧的筷子后，才能就餐，进餐完毕，将碗和筷子放回原位，并继续思考为使尽可能多的哲学家同时就餐,且防止出现死锁现象,请使用信号量的PV操作描述上述过程中的互斥与同步，并说明所用信号量及初值的含义。

```c
semaphore Lock=1;					//互斥信号量
int wan=m;							//代表碗数
int chopstick[n]={1,1,1,1……,1}	;	//代表筷子数

P_i(){					//i号哲学家进程
    while(1){
        P(Lock);		//上锁
        if(wan>=1&&chopstick[i]==1&&chopstick[(i-1)%n]==1){
            chopstick[i]--;
            chopstick[(i-1)%n]--;
            wan--;
            取资源;	  //一次性拿完所有资源	
            V(Lock);	//拿完资源解锁
            break;		//跳出while循环
        }
        V(Lock);		//资源不够，解锁，尝试再次拿资源
    }
    吃饭;
    P(Lock);			//一口气归还所有资源
    chopstick[i]++;
    chopstick[(i-1)%n]++;
    wan++;
    V(Lock)
}
```

```c
semaphore lock=1;					//互斥信号量
int wan=m;							//代表碗数
int chopstick[n]={1,1,1,1……,1}	;	//代表筷子数

P_i(){
    P(lock);
    P(wan);
    P(chopstick[i]);
    P(chopstick[(i-1)%n]);
    吃饭;
    V(lock);
    V(wan);
    V(chopstick[i]);
    V(chopstick[(i-1)%n]);
}
```

# 单纯的同步问题

1.某进程的两个线程T1和T2并发执行 A、B、C、D、E和F共6个操作，其中T1执行A、E、F。T2执行B、C、D。
下图表示上述6个操作的执行顺序所必须满足的约束：C在A和B完成后执行，D和E在C完成后执行，F在E完成后执行。请使用信号量的 P()、V()操作描述T1和T2之间的同步关系，并说明所用信号量的作用及其初值。
![image-20241013113349226](E:\图片\图床\image-20241013113349226.png)

<font color='red'>**重点**</font>：①前V后P【对线而言】
		 	②只有不同进程之间才需要同步，在同一个进程之间不需要同步。

```c
semaphore AC=0;
semaphore CE=0;

T1(){									T2(){
    A;										B;
    V(AC); 									P(AC);
    P(CE); 									C;
    E;										V(CE);
    F;										D;
}										}
```

2.现有5个操作A、B、C、D和E，操作C必须在A和B完成后执行，操作E必须在C和D完成后执行，请使用信号量的P、V 操作描述上述操作之间的同步关系，并说明所用信号量及其初值。

```c
semaphore AC=0;
semaphore BC=0;
semaphore CE=0;
semaphore DE=0;
```

![image-20241014154946348](E:\图片\图床\image-20241014154946348.png)



**<font color='red'>3.</font>**如图所示，三个合作进程P1、P2、P3，它们都需要通过同一设备输入各自的数据a、b、c，该输入设备必须互斥地使用，而且其第一个数据必须由P1进程读取，第二个数据必须由P2进程读取，第三个数据则必须由P3进程读取。然后，三个进程分别对输入数据进行下列计算。最后，P1进程通过所连接的打印机将计算结果x、y、z的值打印出来。请用信号量实现它们的同步。

<font color='red'>**S2、S3已经保证了同一时刻只有一个设备使用，因此不必设置mutex互斥访问输入设备**</font>。

![image-20241014171029421](E:\图片\图床\image-20241014171029421.png)

<img src="E:\图片\图床\image-20241014171102141.png" alt="image-20241014171102141" style="zoom:50%;" />



**<font color='red'>4.</font>**要求使用swap指令和布尔型指令lock实现临界区互斥。lock为线程间共享的变量 ，lock的值为True时线程不能进入临界区，为False时线程能进入临界区。某同学编写的代码如图
（1）图a中的伪代码哪些语句存在错误，将其更为正确语句(不增加语句的条数)
（2）图b给出了交换两个变量值的函数newSape()的代码，是否可以用函数调用语句newSwap(&key,&lock)代替swap(key,lock)以实现临界区互斥？

 <img src="E:\图片\图床\image-20241015151446577.png" alt="image-20241015151446577" style="zoom:67%;" />



```
a图中的进入区将if(key==TRUE)	改为While(key==TRUE)
退出区改为lock=False
```

```
不可以。交换过程必须是一气呵成的，而函数操作并不能保证，所以无法实现临界区互斥
```

















