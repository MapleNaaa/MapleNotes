# 第一章——计算机系统概述

## 计算机发展历程

​	计算机系统=硬件+软件

​	系统软件：操作系统、数据库管理系统DBMS、标准程序库、网络软件系统、语言处理程序、
​						 服务性程序、编译程序、连接程序、分布式软件系统
​	应用软件：微信、QQ、数据库软件DBS

①<font color='blue'>**软件的功能可以使用硬件代替**</font>。
②**<font color='blue'>冯诺依曼机的最根本特征：采用“<font color='red'>存储程序</font>”原理</font>**。
	**<font color='blue'>冯诺依曼机的基本工作方式：<font color='red'>控制流驱动方式</font></font>**。
③<font color='blue'>**软件是指硬件上运行的程序和相关的数据及文档**</font>。
④<font color='blue'>**用户与计算机通信的界面：外围设备**</font> 
	<font color='blue'>**计算机硬件/软件的界面：指令系统**</font> 

## 计算机硬件的组成

1.冯诺依曼结构

​		<img src="E:\图片\图床\image-20240123091922183.png" alt="image-20240123091922183" style="zoom:60%;" />   <img src="E:\图片\图床\image-20240123091935308.png" alt="image-20240123091935308" style="zoom:67%;" />

​		特点：①计算机硬件系统由五大部件组成
​					②指令和数据都是以同等地位存于存储器，可按地址寻访
​					③指令和数据用二进制表示
​					④指令由操作码和地址码组成 
​					⑤采用"存储程序"的工作方式
​					【将事先编制好的程序和原始数据送入主存储器后才能执行，一旦程序被启动执行，无须操作人员干预，计算机会自动逐条执行指令，直到程序执行结束】【即按地址访问并顺序执行指令】
​					⑥<font color='red'>**以运算器为中心**</font>【输入/输出设备与存储器之间的数据传送通过运算器完成——>数据计算的效率降低】

<font color='blue'>**输入输出设备是计算机与外界联系的桥梁**</font>。【I/O设备：输入设备、输出设备、辅存、通信设备】

2.现代计算机结构

​	<img src="E:\图片\图床\image-20240123095700081.png" alt="image-20240123095700081" style="zoom:53%;" />    <img src="E:\图片\图床\image-20240123095709033.png" alt="image-20240123095709033" style="zoom:54%;" />    

​		<font color='red'>**以存储器为中心**</font> 

## 各个硬件的工作原理

**1.计算机硬件的组成** 

​		<img src="E:\图片\图床\image-20240123095824800.png" alt="image-20240123095824800" style="zoom:59%;" />			**但在现代生活中，主存中的MAR与MDR也集成在CPU当中**。

2.**主存储器的基本组成** 

​		存储体、MAR(地址寄存器)、MDR(数据寄存器)
​		**存储体：**存放二进制信息。数据在存储体中按地址存储。存储体被分为一个个的存储单元。
​				存储单元——每个存储单元存放一串二进制代码【每个地址对应一个存储单元，从0开始】
​				存储字——存储单元中二进制代码的组合
​				存储字长——存储单元中二进制代码的位数
​				存储元——存储二进制的电子元件，每个存储元可存1bit
​		**MAR：**存放访存地址，经过地址译码后找到所选的存储单元。
​					  MAR位数反应存储单元的个数**【MAR=4位——>总共有2^4^个存储单元】**
​		**MDR：**用于暂存要从存储器中读或写的信息。
​					 <font color='red'>MDR位数=存储字长</font>**【MDR=16位——>每个存储单元可存放16bit，一个字=16bit】**

​	  **一个字节=8bit，1B=一个字节，1b=1bit，字由计算机硬件决定**。

​		时序控制逻辑：用于产生存储器操作所需的各种时序信号。

 				<img src="E:\图片\图床\image-20240123101200828.png" alt="image-20240123101200828" style="zoom: 67%;" />     			<img src="E:\图片\图床\image-20240123101241242.png" alt="image-20240123101241242" style="zoom:67%;" />    				<img src="E:\图片\图床\image-20240126103712272.png" alt="image-20240126103712272" style="zoom:50%;" />

3.**运算器的基本组成**

​	ALU、ACC、MQ、X、PSW		
​		**算术逻辑单元ALU：**通过内部复杂的电路实现算数运算、逻辑运算【ALU属于组合逻辑电路】【运算器核心】
​		**累加寄存器ACC：**用于存放操作数，或运算结果
​		**乘商寄存器MQ：**在乘、除运算时 ，用于存放操作数或运算结果
​		**操作数寄存器X：**用于存放操作数	
​		**状态寄存器PSW：**存放ALU运算得到的一些标志信息或处理机的状态信息【是否溢出、有无进位、结果是否为负】										【也可称为 标志寄存器】

 		<img src="E:\图片\图床\image-20240123102416644.png" alt="image-20240123102416644" style="zoom:67%;" />	<img src="E:\图片\图床\image-20240123102428971.png" alt="image-20240123102428971" style="zoom:80%;" />

若1111∗1111=111000001	则1110为乘积高位	0001为乘积低位

<u>运算器中含有</u>：ALU、ACC、MQ、X、PSW、移位器、计数器、变址寄存器IX、基址寄存器BR 

4.**控制器的基本组成**

​	CU、IR、PC
​		**控制单元CU**：分析指令，给出控制信号
​		**指令寄存器IR**：存放当前执行的指令【IR中的内容来源于主存的MDR】
​		**程序计数器PC**：存放下一条指令地址，有自动加一功能【PC与主存的MAR之间有一条直接通路】

​	<img src="E:\图片\图床\image-20240123102651914.png" alt="image-20240123102651914"  /> 

<u>控制器中含有</u>：CU、IR、PC、指令译码器【地址译码器在内存中】、时序系统、微操作信号发生器

①<font color='blue'>**CPU存取速度：寄存器>Cache>内存**</font>。
②**<font color='blue'>计算机系统的地址空间 = 2^n^	【计算机系统以n位表示地址】</font>**。
③**<font color='blue'><font color='red'>主存</font>之中含有<font color='red'>地址译码器</font>。CPU中没有</font>**。
④<font color='blue'>**运算器中含有数据总线**</font>。
⑤**<font color='blue'>CPU<font color='red'>区分指令和数据</font>的依据：指令周期的不同阶段</font>**【在取指令阶段取出的为指令、在执行指令阶段取出的即为数据】		<font color='blue'>**通过地址来源区分**</font>【由PC提供存储单元地址取出的是指令、由指令地址码部分提供存储单元地址取出的是操作数】
⑥**<font color='blue'><font color='red'>寄存器</font>由<font color='red'>触发器</font>组成</font>**。
⑦**<font color='blue'>在CPU的寄存器中，<font color='red'>指令寄存器</font>对用户是<font color='red'>完全透明</font>的</font>**。
⑧<font color='blue'>**用户程序不能直接访问底层硬件（外部设备），需要通过操作系统内核来完成**</font>。

## 工作过程	

```
M——主存中某存储单元
ACC、MQ、X、MAR、MDR....——相应寄存器
M(MAR)——取主存储单元中的数据
(ACC)...——取相应寄存器中的数据指令
OP(IR)——取操作码
Ad(IR)——取地址码
```

![img](https://img-blog.csdnimg.cn/20210117172058667.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![image-20240124095146147](E:\图片\图床\image-20240124095146147.png)

![img](https://img-blog.csdnimg.cn/20210117172909779.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

```
存数指令：将ACC中的内容存储到指定的存储单元中【即地址码指定的存储单元中】
```

![img](https://img-blog.csdnimg.cn/20210117173204649.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20210117173316604.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2ppZV9kdWFu,size_16,color_FFFFFF,t_70)

在计算机的工作过程中，前5步的操作都是相同的【取指令和分析指令】。对于不同的指令具体的步骤不同。	

## 计算机系统的层次结构

**1.计算机系统的层次结构** 

​		<img src="E:\图片\图床\image-20240124110056696.png" alt="image-20240124110056696" style="zoom: 73%;" /> 

​	透明——程序员不可见

**2.三种级别的语言** 

 <img src="E:\图片\图床\image-20240823164321511.png" alt="image-20240823164321511" style="zoom:50%;" />

翻译程序：编译、汇编、解释
	编译程序：将高级语言编写的源程序全部语句一次全翻译成机器语言程序，而后再执行机器语言程序【只需翻译一次】
	解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句【每次执行都翻译】

 .exe后缀的为机器语言程序

**指令集体系结构ISA**——定义一台计算机可以支持哪些指令、以及每条指令的作用是什么、用法是什么。

---

①**<font color='blue'>解释程序的运行速度比编译程序<font color='red'>较慢</font></font>**。 
②**<font color='blue'>翻译程序——编译程序、汇编程序、解释程序</font>**。 
				**<font color='blue'>编译程序和汇编程序的不同在于——源文件不同</font>**。 
				**<font color='blue'>解释程序不生产目标代码</font>**。 
③**<font color='blue'>汇编语言与机器结构有关</font>**。 
④**<font color='blue'>汇编指令和机器指令一一对应，功能相同</font>**。 
⑤**<font color='blue'>汇编语言和机器语言与机器指令对应，而高级语言不与指令对应，具有较好的可移植性</font>** 。
⑥<font color='blue'>**计算机硬件并<font color='red'>不能直接执行</font>硬件描述语言程序。硬件能直接执行的只有机器语言**</font>。
⑦<font color='blue'>**任何程序在运行前都要转换为机器语言程序**</font>。
<img src="E:\图片\图床\image-20240128225522418.png" alt="image-20240128225522418" style="zoom:50%;" />			<img src="E:\图片\图床\image-20240128225544009.png" alt="image-20240128225544009" style="zoom:50%;" /> 

**3.计算机系统的工作原理**  

<img src="E:\图片\图床\image-20240805162454367.png" alt="image-20240805162454367" style="zoom: 67%;" />

可执行文件一般放在外设中

## 计算机的性能指标

**1.机器字长** 

某16位或32位机器，其中16位和32位就是机器字长。

<u>字、字长、机器字长、存储字长和指令字长的关系</u>：
	字长：CPU内部用于整数运算的数据通路的宽度。【字长=CPU内部用于整数运算的运算器位数=通用寄存器宽度】
	字：表示被处理信息的单位。不同机器的字的位数可能不同。
	机器字长：计算机进行一次整数运算所能处理的二进制的位数。
	指令字长：一个指令中二进制的位数
	存储字长：存储单元中二进制的位数【MDR】。指令字长一般为存储字长的整数倍。

<font color='blue'>机器字长通常与寄存器位数、ALU有关</font>。
<font color='blue'>机器字长=通用寄存器位数=ALU宽度 </font>。
	<font color='red'>PC位数=MAR位数=存储器的字数</font>
	<font color='red'>IR位数=指令字长</font>
	<font color='red'>MDR=数据总线宽度</font>
	<font color='red'>MAR=地址总线宽度【一般来说,PC=MAR】</font>
	<font color='red'>寄存器=ALU=机器字长</font>
	<font color='red'>机器字长通常为字节(8位)的整数倍</font>。

**2.数据通路带宽** 

数据通路带宽——数据总线一次所能并行传送信息的位数。
			【此处的数据通路带宽指的是外部数据总线的宽度，与CPU内部总线宽度（内部寄存器大小）可能有所不同】
数据通路——各个子系统通过数据总线连接形成的数据传送路径。

**3.主存容量**

总容量 = 存储单元个数 * 存储字长bit
​			 = 存储单元个数 * 存储字长 / 8Byte
【MAR位数反映存储单元的个数、MDR位数=存储字长=每个存储单元的大小】

<font color='brown'>MAR为32位，MDR为8位，总容量=2^32^ * 8bit = 4GB</font > 

**4.运算速度** 

**(1)吞吐量：**系统在单位时间内处理请求的数量。<font color='blue'>主要取决于主存的存取周期</font >。【评价计算机系统性能的综合参数】
**(2)响应时间：**从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。

**(3)CPU时钟周期：**每个脉冲信号的时间称为CPU时钟周期。CPU工作的最小时间单位。
	【时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定】
	【<u>CPU周期=机器周期</u>，每个机器周期又包含若干个CPU时钟周期】
	【<u>时钟周期以指令流水线的每个流水段的最大延迟时间确定</u>】
	 <font color='orange'>**时钟周期数 = 指令条数 * CPI = CPU执行时间 *  主频**</font> 

**(4)CPU主频：**CPU脉冲信号振荡的频率。CPU的时钟频率，CPU时钟周期的倒数。
					 	  主频越高，完成指令的一个步骤所需的时间越短，指令执行速度越快。
							【x主频表示1秒有x个时钟周期】

**(5)CPI：**执行一条指令所需的时钟周期数。【不同指令的CPI不同、相同指令的CPI也可能不同】
				 IPC为CPI的倒数
	 		   <font color='orange'>**执行一条指令的耗时 = CPI * CPU时钟周期**</font>			

<font color='orange'>**CPU执行时间=CPU时钟周期数/主频=（指令条数*CPI）/主频**</font>				

<font color='brown'>某CPU主频为1000Hz，某程序包含100条指令，平均来看指令的CPI=3。该程序在该CPU上执行需要多久?</font > 
<font color='brown'>100 * 3 * 1/1000=0.3s</font> 

主频高的CPU不一定比主频低的CPU快【还要看CPI】
A的主频高于B的主频，且A与B的CPI相同，但A也不一定更快
				【还要看指令系统，如A不支持乘法指令，只能用多次加法指令来实现乘法，而B却支持乘法指令】

**(6)IPS：**每秒执行多少条指令。【也称为计算机的运行速度】	
		<font color='blue'>  标志系统性能的最有用的参数是<font color='red'>MFLOPS</font>。</font > 
		 <font color='orange'>  **IPS = 主频/平均CPI = 1/一条指令时间** </font> 

**(7)FLOPS：**每秒执行多少次浮点运算。

<font color='blue'>对于IPS和FLOPS会使用K,M,G,T来修饰——KIPS,MIPS,KFLOPS,MFLOPS</font>
K=Kilo=千=10^3^		M=10^6^		G=10^9^		T=10^12^	P=10^15^	

在描述文件大小、存储容量的时候，K、M、G、T通常认为是2的次方
在描述速率、频率的时候，K、M、G、T通常认为是10的次方

**(8)系统的整体性能指标(动态测试)**
		基准程序是用来测量计算机处理速度的一种程序。【鲁大师测分】

**(9)几个专业术语** 
		系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。
		兼容：指软件或硬件的通用性，即运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。
		软件可移植性：把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。
		固件：将程序固化在ROM中组成的部件。【固件是具有软件特性的硬件】【执行速度快于软件、灵活性快于硬件】

```
CPI——执行一条指令所需的时钟周期数		【执行一条指令的耗时 = CPI * CPU时钟周期】
IPS——每秒执行多少条指令			    【IPS=主频/平均CPI=1/一条指令时间】
FLOPS——每秒执行多少次浮点运算
```

①<font color='blue'>**IPS称为计算机速度**</font>。
②**<font color='blue'>决定计算机<font color='red'>计算精度</font>的主要指标——<font color='red'>计算机字长</font></font>**。
③<font color='blue'>**系列机的基本特性是指令系统向后兼容**</font>
④<font color='blue'>**CPI与时钟频率无关。与系统结构、指令集、计算机组织有关**</font>。
	 <font color='blue'>**时钟频率改变的是程序运行的速度，不会影响CPI**</font>。
⑤<font color='blue'>**设计高性能计算机的重要途经是：采用并行处理技术**</font>。
⑥<font color='blue'>**CPU性能，即CPU执行时间，取决于三个要素：主频、CPI和指令条数**</font>。

# 第二章——数据的表示和运算

## 数制与编码

### **进制**

​	基数：每个数码位所用到的不同符号的个数，r进制的基数为r

​	二进制转十进制：101.1——>1 * 2^2^ + 0 * 2^1^ + 1*2^1^ + 1 * 2^-1^ = 5.5
​	八进制转十进制：5.4——>5 * 8^0^ + 4 * 8^-1^ = 5.5
​	十六进制转十进制：5.8——> 5 * 16^0^ + 8 * 16^-1^ = 5.5

​	二进制转八进制：【三位一组，每组转换成对应的八进制符号】
​						如111000010.01101	<img src="E:\图片\图床\image-20240130095635085.png" alt="image-20240130095635085" style="zoom:67%;" />
​	二进制转十六进制：【四位一组，每组转换成对应的十六进制符号】
​						如111000010.01101	<img src="E:\图片\图床\image-20240130095822371.png" alt="image-20240130095822371" style="zoom: 67%;" />

​	八进制转二进制：【每位八进制数对应三位二进制】
​						(251.5)——>010 101 001. 101
​	十进制转二进制：【拼凑法】
​						0.5	0.25	0.125	
​					【当小数部分无法精确表示时候，使用乘基取整法——小数乘2，取下整数部分，依次循环】
​	十六进制转二进制：【每位十六进制对应四位二进制】
​						(AE86.1)——>1010 1110 1000 0110. 0001

二进制表示——101<font color='red'>B</font>
十六进制—— 162<font color='red'>H</font>	<font color='red'>0x</font>162
十进制——1652<font color='red'>D</font> 

模运算：
		-3 mod 12 = 9			
		-15 mod 12 = 9
		模运算得到的余数，是非负数

### **定点数的编码表示** 

**1.真值和机器数**
	真值：符合人类习惯的数字，计算机所代表的实际值。
	机器数：数字实际存到机器里的形式，正负号需要被“数字化”。

**2.机器数的定点表示** 
	**<font color='red'>在现代计算机中，通常用补码整数表示整数，原码小数表示浮点数的尾数部分，移码表示浮点数的阶码部分。</font>**  

​	定点表示法用来表示定点小数和定点整数。
​	（1）定点小数：定点小数是纯小数，即无整数部分。小数点位置在符号位之后，最高有效位之前。
​	（2）定点整数：定点整数是纯整数。小数点位置在最后。
​					<img src="E:\图片\图床\image-20240710142654320.png" alt="image-20240710142654320" style="zoom: 45%;" />
​	

**3.原码、补码、反码、移码** 
	由符号位和数值位组成，符号位为0：正数		符号位为1：负数

​	原码：	
​		优点：①与真值对应关系简单、直观			②原码乘除运算简单
​		缺点：①0的表示不唯一	②原码加减运算复杂【符号位不能参与运算，需设计复杂的硬件电路才能处理，贵】
​		<font color='blue'>原码小数：1-2^-n^ = 2^-1^+2^-2^+…+2^n-1^ </font> 

​	移码：在补码的基础上符号位取反。【移码只能用于表示整数】

​			原码和反码的合法表示范围完全相同，都有两种方法表示真值0
​			补码的合法表示范围比原码多一个负数，只有一种方法表示真值0
​	
​			考点：两个数A和B进行某种运算后，是否发生溢出?――手算做题可以带入十进制验证，是否超出合法范围

![image-20240130160324307](E:\图片\图床\image-20240130160324307.png) 

<img src="E:\图片\图床\image-20240130141928676.png" alt="image-20240130141928676" style="zoom: 67%;" />

<img src="E:\图片\图床\image-20240130142707882.png" alt="image-20240130142707882" style="zoom:67%;" />

【<font color='red'>[X]~补~+[Y]~补~ = 2+(X+Y)=[X+Y]~补~ </font >】

### **整数的表示**

**1.无符号整数的表示** 
		机器字长限制了①计算机最多只能同时进行x位运算
									 ②通用寄存器只能存x位
		n bit无符号整数表示范围0~2^n^-1，超出则溢出，意味着该计算机无法一次处理这么多
		计算机硬件能支持的无符号整数位数有上限

​		加法运算：从最低位开始，按位相加，并往更高位进位
​		减法运算：①“被减数”不变，“减数”全部位按位取反、末位+1，减法变加法
​							 ②从最低位开始，按位相加，并往更高位进位

**2.有符号整数的表示** 
		符号数值化，将符号位放在有效数字的前面。

### **定点小数**	

​		表示：原码、反码、补码
​		小数点隐含在符号位后面
​		定点小数的表示转换以及加减运算与定点整数相同【定点整数：带符号的整数】

定点小数与定点整数的区别——位数扩展时，扩展位置不一样
		定点小数扩展在末端
		定点整数扩展在首段

------

**<font color='blue'>	①8原码可以表示的不同数据个数为——255【因为原码0的表示方式有两种，因此2^8^-1】</font>** 
	**<font color='blue'>②n位二进制小数可以表示的个数为——2^n^	</font>** 
**<font color='blue'>	n位10进制小数可表示的个数——10^n^ </font>** 
**<font color='blue'>	③在计算机中通常使用<font color='red'>无符号数</font>来表示<font color='red'>主存地址</font></font>** 
	**<font color='blue'>④-32的补码——1，00000 </font> **  

### **C语言中的整数类型和转换** 

​	**1.C语言中的整型数据类型** 
​			char（8位/1B）——无符号整数
​			short、short int（16位/2B）——补码存储
​			int（32位/4B）——补码存储
​			long、long int（32位/64位）——补码存储

```c
//x=-4321 	y=61215
short x = -4321;						//unsigned表示无符号数	
unsigned short y = (unsigned short)x;	//无符号数与有符号数：不改变数据内容，但是改变解释方式

int a=165537,b=-34911;	//int占4字节	short占2字节
short c=(short)a, d=(short)b;	//长整数变短整数：高位截断、保留低位


short x=-4321;
int m=x;		//短整数变长整数：符号拓展
unsigned short n = (unsigned short)x;	
unsigned int p=n;
```

<font color='blue'>**①若i与n都是无符号整数，则i<n属于无符号数比较，转换为二进制比较**</font>。	
**<font color='blue'>②在C语言中，无符号和有符号进行运算，按照无符号数进行运算</font>**。

## 运算方法和运算电路

### **奇偶校验码**

​		奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数
​		偶校验码：整个校验码（有效信息位和校验位）中“1”的个数位偶数
​		但是，如果校验码中出现了偶数个变化，则奇偶校验码无法检验出错误

​	偶校验的硬件实现：各信息进行异或（模2加）运算，得到的结果即为偶校验码【异或：相同得0，不同得1】
​	进行偶校验（所有位进行异或运算，若结果为1说明出错）

### **基本运算部件** 

运算器由算术逻辑单元ALU、移位器、状态寄存器PSW、通用寄存器等组成。
ALU的核心部件：加法器
ALU属于组合逻辑电路

**1.算术逻辑单元ALU**
		功能：
				算术运算——加、减、乘、除
				逻辑运算——与、或、非、异或
				辅助功能——移位、求补

​		最基本的逻辑运算：与、或、非
​				优先级：与>或
​				三者的门电路	<img src="E:\图片\图床\image-20240131112105570.png" alt="image-20240131112105570" style="zoom:80%;" />

​		复合逻辑：与非、或非、异或、同或
​				与非：![image-20240131134435792](E:\图片\图床\image-20240131134435792.png)		或非：![image-20240131134456896](E:\图片\图床\image-20240131134456896.png)		异或：![image-20240131134517571](E:\图片\图床\image-20240131134517571.png)【相同为0、不同为1】		
​																										  同或：![image-20240131140150806](E:\图片\图床\image-20240131140150806.png)【相同为1，不同为0】

​				四者的门电路	<img src="E:\图片\图床\image-20240131140416303.png" alt="image-20240131140416303" style="zoom:75%;" />

​		控制信号位数≥log~2~k【k为ALU支持的K种功能】

**2.加法器选择知识点汇总：**
<font color='blue'>**①提高串行加法器效率：提高进位产生和传递的速度。**</font> 
<font color='blue'>**②x=67，y=38。在x-y的时候，需要将y变为[-y]~补~。但是<font color='red'>加法器关于y的输入端的信息为y取反</font>，而不是将y取反加1**</font> 
	<font color='blue'>**【做减法时，低位进位信息为1；做加法时，低位进位信息为0】**</font> 

### **定点数的移位运算**

左移乘2，右移除2

**1.逻辑移位** 
逻辑移位将操作数看作，无符号整数。
	移位规则：
			左移时，高位移出，低位补0；【可能发生溢出】
			右移时，低位移出，高位补0；

**2.算术移位** 
算术移位将操作数看作，有符号整数。

补码移位：
	人移：符号位不动。左移补0，右移补符号位。

​	机移：将符号位和数值位一起移动。
​			判断溢出——判断移动前后的符号位是否相同【溢出的移动与王道书上的不一样，但是溢出数据错误，不再使用】
​			移动规则——左移：低位补0
​									右移：高位补符号位

**<font color='blue'>双符号位的最高位代表真正的符号，而低位符号位用于参与移位操作以判断是否发生溢出。</font>** 

**3.循环移位** 
		不带进位位的循环移位：左移时，溢出的放到右边。右移同理。【最高位进入最低位置和标志寄存器】
		带进位位的循环移位：连带进位位一同循环移动。

### **定点数的加减运算** 

**1.补码的加减运算** 
	[A+B]~补~ = [A]~补~ + [B]~补~ 
	[A-B]~补~ = [A]~补~ + [-B]~补~ 

加法运算：从最低位开始，按位相加(<font color='red'>符号位参与运算)</font>，并往更高位进位【保留机器字长的位数、超出的丢弃】
减法运算：<img src="E:\图片\图床\image-20240130143659558.png" alt="image-20240130143659558" style="zoom:50%;" />	
										也可以【从右往左找到第一个1，这个1左边的所有位(包括符号位)按位取反】

**2.无符号数的加减运算** 
	加法：两数相加
	减法：B—>[-B]~补~ 

### **溢出判断**

​		正数+正数 才会发生<font color='red'>上溢</font>【正+正=负】
​		负数+负数 才会发生<font color='red'>下溢</font>【负+负=正】

​	**1.采用一位符号位：**
​			设A的符号为A~s~，B的符号为B~s~，运算结果为S~s~，则溢出逻辑表达式为	<img src="E:\图片\图床\image-20240201134738688.png" alt="image-20240201134738688" style="zoom:67%;" />
​		若V=0，表示无溢出		若V=1，表示有溢出 

> https://www.bilibili.com/video/BV1ps4y1d73V?t=1123.6&p=19

​	**2.采用一位符号位、根据数据位进位情况判断溢出：**	
​						符号位的进位C~s~	最高数值位的进位C~1~ 	 【C~1~：从最高数值位向符号位的进位】
​		上溢				0									1
​		下溢				1									0
​			即【当C~s~与C~1~不同时有溢出】

> https://www.bilibili.com/video/BV1ps4y1d73V?t=1317.6&p=19

​	**3.采用双符号位**	
​		 正数符号为00，负数符号为11
​			上溢——01		下溢——10

​			变形补码/模4补码：双符号位
​		【<font color='red'>实际存储时只存储一个符号位，运算时会赋值</font>】

 <img src="E:\图片\图床\image-20240201143615631.png" alt="image-20240201143615631" style="zoom:80%;" />		<img src="E:\图片\图床\image-20240201143712591.png" alt="image-20240201143712591" style="zoom: 60%;" />

<font color='blue'>**①计算运算发生溢出的根本原因：寄存器的位数有限**</font>。
②


### **寄存器标志**

OF：溢出标志。溢出时为1，否则为0【<font color='red'>对有符号数而言</font>】最高位和次高位异或
SF：符号标志。负号时为1，否则为0【<font color='red'>对有符号数而言</font>】
ZF：零标志。结果是0为1，否则为0
CF：进位/借位标志。进位/借位时置1，否则置0【<font color='red'>对于无符号数而言的</font>】	【sub=1表示减法、sub=0表示加法】
	【CF加法，有进位。CF减法时，借位】
			【加法——看是否有进位】
			【减法——大数-小数无借位，小数-大数有借位】
	CF=C~out~ ⊕sub 

<font color='red'>**标志位信息送入PSW**</font> 

### **定点数的乘除法**


#### **原码乘法**

​			原码一位乘法**【先加法再移位，重复n次(n位数值位长)】**【**<font color='red'>移位是逻辑移位</font>**】
​					符号位单独运算：符号位=X~s~⊕Y~s~
​					数值位取绝对值进行乘法计算 
​			原码中移动的小数点的位数为——>两个乘法的小数点位数相加
​			<img src="E:\图片\图床\image-20240227093305899.png" alt="image-20240227093305899" style="zoom:67%;" />

​			机器运算
​					在正式进行乘法之前，ACC置0
​					MQ中，若当前位=1，则ACC加被乘数、若当前位=0，则ACC加0【从最后一位开始计算】
​					因为要发生错位，因此ACC连同MQ二者一起逻辑右移【此右移包括将ACC的数据右移到MQ中】

​			手算
​					<img src="E:\图片\图床\image-20240227154906992.png" alt="image-20240227154906992" style="zoom: 50%;" />

#### **补码乘法**

​			补码一位乘法**【进行n轮加法、移位，<font color='red'>最后再多来一次加法</font>】**【<font color='red'>**移位是算术移位**</font>】【**<font color='red'>符号位参与运算</font>**】
​				辅助位-MQ最低位 = 1时，(ACC)+[x]补
​				辅助位-MQ最低位 = 0时，(ACC)+0
​				辅助位-MQ最低位 = -1时，(ACC)+[-x]补						

```
辅助位为MQ扩展的一位。
辅助位初始为0。每次右移会使MQ的最低位顶替原来的辅助位。
```

<img src="E:\图片\图床\image-20240227160837315.png" alt="image-20240227160837315" style="zoom:67%;" />  

因计算机中寄存器的位数是统一的，所以ACC与X也会多加一位，因此采用双符号位补码运算。MQ采用单符号位补码

​	<img src="E:\图片\图床\image-20240228105407561.png" alt="image-20240228105407561" style="zoom:80%;" />

----

①实现N位(不包括符号位)补码一位乘时，乘积为<font color='red'>2N+1</font>位
	<font color='blue'>因为右移了n次——2N；再加上符号位2N+1</font>



#### **原码除法**

​	**手算二进制**
​				   <img src="E:\图片\图床\image-20240228112311171.png" alt="image-20240228112311171" style="zoom:50%;" />

​				规律：忽略小数点，每确定一位商，进行一次减法，得到4位余数，在余数末尾补o，再确定下一位商。
​							确定5位商即可停止（机器字长为5位)

​	**恢复余数法**
​			若余数为负时商0，并加[|y|]~补~，再左移，再-|除数|

​			符号单独处理
​			数值位取绝对值进行除法计算

​			计算机一开始默认上商1，如果错误再改上商0，并恢复余数
​			【当上商1的时候，被除数/余数-除数(即ACC-[-|y|]~补~)，把结果放入到ACC中】
​			【若相减是负数(符号位为1)，说明应该上商0】
​			【然后把ACC中的数值恢复原样——>ACC当前数值的结果上加上除数】
​			【ACC连同MQ一起逻辑左移】

​			余数=ACC中的数据 * 2^-n^【n为数值位】		余数的正负性与商相同

​		手算模拟
​				<img src="E:\图片\图床\image-20240228150411114.png" alt="image-20240228150411114" style="zoom: 60%;" />

**加减交替法/不恢复余数法**	
			符号位单独运算

​			若余数为负，则可直接商0，并让余数左移1位再加上[|y|]~补~


​			余数的正负性与商相同

​			若最后的余数为负，需要商0，并+[|y|]~补~得到正确余数

​			<img src="E:\图片\图床\image-20240228155435740.png" alt="image-20240228155435740" style="zoom:67%;" />

#### **补码除法**	

**加减交替法**

​	符号位参与运算
​	被除数/余数、除数采用双符号位

​	被除数和除数同号，则被除数减去除数;
​	异号则被除数加上除数。

​	余数和除数同号，商1，余数左移一位减去除数;
​	余数和除数异号，商0，余数左移一位加上除数。
​	重复n次

​	![image-20240316234030457](E:\图片\图床\image-20240316234030457.png)



----

**//原码乘法**	【进行n轮加法、右移】
ACC一开始置0
若MQ最低位为0,ACC加0；若MQ最低位为1，ACC加被加数
先加法再右移，重复n次【n为数值位】	【移位是逻辑移位，ACC连同MQ一起移位】
<font color='red'>ACC为双符号位、MQ无符号位</font>
![image-20240302233037552](E:\图片\图床\image-20240302233037552.png)

**//补码乘法**	【进行n轮加法、右移，<font color='red'>最后再多来一次加法</font>】
ACC一开始置0
辅助位-MQ最低位 	为1，ACC+[x]补； 为0，ACC+0； 为-1，ACC+[-x]补
先加法再移位，重复n次【n为位数值位长】，最后才执行一次加法	【移位为算术移位，ACC连同MQ一起移位】	
	符号位不动，数值位右移，正数右移补0，负数右移补1（符号位是啥就补啥)
左移n次，上商n+1次【n为数值位】
<font color='red'>符号位参与运算【ACC与X符号位为2位，MQ符号位为1位】</font>
![image-20240302233111594](E:\图片\图床\image-20240302233111594.png)

**//原码除法——恢复余数法**
被除数/余数-除数(即ACC+[-|y|]补):若结果为负数，商0，此结果再加[|y|]补，然后左移；
							 若结果为正数，商1，左移
商为n位【n位ACC或MQ中的位数，0.123商4位】	【若最终余数为负，需要商0，加[|y|]补得到正确余数】
<font color='red'>单符号位</font>

**//原码除法——不恢复余数法/加减交替法**
被除数/余数-除数(即ACC+[-|y|]补):若结果为负数，商0，然后左移，此结果再加[|y|]补，；
							 								 若结果为正数，商1，然后左移，此结果再加[-|y|]补
加/减n+1次，每次加减确定一位商。左移n次（最后一次加减完不移位）最终可能还要再多加一次
【若最终余数为负，需要商0，加[|y|]补得到正确余数】
<font color='red'>单符号位</font>

**//补码除法**	【同号减商1、异号加商0】	【异号相除是看够不够减，够减商0，不够减商1】
①被除数和除数同号，则被除数减去除数;
	异号则被除数加上除数。
②余数和除数同号，商1，余数左移1位减去除数	【注意商是从第二步开始的】
	余数和除数异号，商0，余数左移1位加上除数
	重复n次【n为机器字长(符号位+数值位)】
③末位商，恒置为1

<font color='red'>符号位参与运算；被除数/余数、除数采用双符号位</font>  

## 浮点数的表示和运算

定点数可表示的数字范围有限

采用规格化的浮点数最主要是为了——<font color='red'>增加数据的表示精度 </font> 

### **表示**

​    <img src="E:\图片\图床\image-20240228180851973.png" alt="image-20240228180851973" style="zoom: 67%;" />

浮点数的真值： N = (-1)^s^ * r^E^ * M	【r为阶码的基数，通常为2】【基数越大、范围越大、但精度变低】

阶码E反映浮点数的表示范围及小数点的实际位置
尾数M的数值部分的位数n反映浮点数的精度 

尾数给出一个小数，阶码指明了小数点要向前/向后移动几位

![image-20240825152900459](E:\图片\图床\image-20240825152900459.png)     ![image-20240825153007370](E:\图片\图床\image-20240825153007370.png)

**<font color='brown'>例：阶码和尾数均采用补码表示，求a、b的真值</font>** 
	**<font color='brown'>	a=0,01;1.1001 </font>** 
		**<font color='brown'>b=0,10;0.01001</font>** 

**<font color='brown'>a：阶码0,01对应真值+1</font>** 
	 **<font color='brown'> 尾数1.1001对应真值-0.0111=-(2^-2^+2^-3^+2^-4^)</font>** 
	**<font color='brown'>  a的真值=2^1^ * (-0.0111) = -0.111</font>** 

**<font color='brown'>b：阶码0,10对应真值+2</font>** 
**<font color='brown'>	  尾数0.01001对应真值+0.01001 = +(2^-2^ + 2^-5^)</font>** 
 	**<font color='brown'> b的真值=2^2^ * (+0.01001) = +1.001</font>** 

### **浮点数尾数规格化**

​	规格化——是对尾数进行规格化。但是由于尾数发生变化，阶数也会随之变化

​	若采用1B的存储空间，上述例子中的a可完全存储，但是b不可以完全存储
​	<img src="E:\图片\图床\image-20240228184622941.png" alt="image-20240228184622941" style="zoom:67%;" />				<img src="E:\图片\图床\image-20240228184607940.png" alt="image-20240228184607940" style="zoom:67%;" />

​	将b左规	<img src="E:\图片\图床\image-20240228193115933.png" alt="image-20240228193115933" style="zoom:67%;" />

​	规格化浮点数：尾数的数值位的最高位为有效值
​		左规——当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。【<font color='red'>左规可进行多次</font>】
​		右规——当浮点数运算的结果尾数出现溢出(双符号位为01或10)时，将尾数算数右移一位，阶码加1【<font color='red'>右规最多一次</font>】						右规可能造成阶码溢出
​		<img src="E:\图片\图床\image-20240228204132353.png" alt="image-20240228204132353" style="zoom:67%;" />

### **规格化浮点数的特点**

​	1.用原码表示的尾数进行规格化：	【规格化的原码尾数最高数值位一定是1】
​			正数为0.1xxx的形式，其最大值为0.11...1；最小值表示为0.10..0
​					尾数的表示范围为1/2≤M≤(1-2^-n^)
​			负数为1.1xxx的形式，其最大值为1.10...0；最小值表示为1.11..1
​					尾数的表示范围为-(1-2^-n^)≤M≤-1/2

​	2.用补码表示的尾数进行规格化：	【规格化的补码尾数，符号位与最高数值位一定相反】
​			正数为0.1xxx的形式，其最大值为0.11...1；最小值表示为0.10..0
​					尾数的表示范围为1/2≤M≤(1-2^-n^)
​			负数为1.0xxx的形式，其最大值为1.01...1；最小值表示为1.00..0	【数值位的最高位为0】
​					尾数的表示范围为-1 ≤ M ≤ -(1/2+2^-n^)

​		<font color='brown'>**若某浮点数的阶码、尾数都使用补码表示，共4+8位；0.110;1.1110100如何规格化？**</font>
​		因为要求补码，所以要求1.0，因此尾数左移3位；阶码也要-3	0.110——>0.011

<img src="E:\图片\图床\image-20240301110653009.png" alt="image-20240301110653009" style="zoom:67%;" />

### **浮点数标准IEEE754**

在计算机中默认将float和double默认是IEE754的单精度变量

移码的定义：移码=阶码真值+偏置值【偏置值为2^n-1^】【这种偏置值的移码就是补码的符号位取反】【n为阶码位数】
​	**<font color='brown'>真值 = -3 = -11B</font>**
​	**<font color='brown'>移码 = -11 + 1000 0000 = 0111 1101</font>**

​	但是偏置值也可以是其他值，IEEE754要求偏置值为2^n-1^-1
​	**<font color='brown'>真值 = -128 = -1000 0000B</font>** 
​	**<font color='brown'>移码 = -1000 0000 + 0111 1111 = 1111 1111</font>** 

<img src="E:\图片\图床\image-20240228225820615.png" alt="image-20240228225820615" style="zoom:67%;" />

<font color='red'>**有关尾数隐藏1，在754—>真值时才发挥作用**</font>    

 				<img src="E:\图片\图床\image-20240228230600387.png" alt="image-20240228230600387" style="zoom: 80%;" />

 				<img src="E:\图片\图床\image-20240228230802705.png" alt="image-20240228230802705" style="zoom: 80%;" />  

![image-20240228231032399](E:\图片\图床\image-20240228231032399.png)

当阶码E全为0，尾数M不全为0时，表示非规格化小数 ±(0.xx...x)~2~ × 2^-126^【隐含最高位变为0】【阶码真值固定视为-126】
当阶码E全为0，尾数M全为0时，表示真值±0
当阶码E全为1，尾数M全为0时，表示无穷大±oo
当阶码E全为1，尾数M不全为0时，表示非数值“NaN"(Not a Number)【如: 0/0、oo-oo等非法运算的结果就是NaN】

![image-20240228232212404](E:\图片\图床\image-20240228232212404.png)

<font color='red'>**可将移码看作无符号数，用无符号数的值减去偏置值，从而求出阶码真值**</font>。

### **浮点数运算**

​	浮点数加减运算步骤：
​		1.对阶——一般阶数更小的向更大的看齐,使尾数移动，从而使阶数变化
​		2.尾数加减
​		3.规格化
​		4.舍入
​			①就近舍入：类似于十进制数运算中的四舍五入法，即在尾数右移时，被移去的最高位数值位为0，则舍去；
​							被移去的最高数值位为1，则在尾数的末位加1。这样做可能导致尾数再次溢出，此时需要再做一个右规。							11100,10.110001011——>11101,11.011000101——>11101,11.011000110
​			②恒置“1”法：尾数右移时，不论丢掉的最高数值位是“1”还是“0”，都使右移后的尾数末位恒置“1”。
​									   这种方法同样有使尾数变大和变小的两种可能。
​							11100,10.110001011——>11101,11.011000101——>11101,11.011000101
​			③正向舍入：朝数轴＋∞方向舍入
​			④负向舍入：朝数轴- ∞方向舍入
​			⑤截断法：直接截取所需要的位数，舍弃后面的所有位
​		5.判溢出
​				若阶码上溢，抛出异常（中断)【右规和尾数舍入】
​				若阶码下溢，当作机器零处理【左规】

​	**<font color='brown'>9.85211 * 10^12^  + 9.96007 * 10^10^ </font>**
​	<font color='brown'>① 9.85211 * 10^12^  + 0.0996007 * 10^12^ </font>
​	<font color='brown'>② 9.9517107 * 10^12^  </font>
​	<font color='brown'>③此式子不需要规格化</font> 
​	<font color='brown'>④若规定只能保留6位有效尾数，则</font>
​			<font color='brown'>9.9517107 * 10^12^ ——> 9.95171 * 10^12^      【多余的直接砍掉】</font>
​		<font color='brown'>或者9.9517107 * 10^12^ ——> 9.95172 * 10^12^  【若砍掉部分非0，则入1】</font>
​		<font color='brown'>或者，也可以采用四舍五入的原则，当舍弃位≥5时，高位入1</font>
​	<font color='brown'>⑤若规定阶码不能超过两位，则运算后阶码超出范围，则溢出</font>
​		<font color='brown'>如：9.85211 * 10^99^  + 9.96007*10^99^ = 19.81218 * 10^99^	</font>
​		<font color='brown'>规格化并按四舍五入以后保留6位尾数，得到1.98122 * 10^100^ </font>
​		<font color='brown'>阶码超过2位，发生溢出</font>



​	<font color='brown'>**已知十进制数X=-5/256，Y=+59/1024，按机器补码浮点运算规则计算X-Y，结果用二进制表示，浮点数规格如下：阶符取2位，阶码取3位，数符取2位，尾数取9位**</font>

<font color='brown'>0.转换格式</font> 
<font color='brown'>	5=101B	1/256 = 2^-8^ ——>X=-101 * 2^-8^ = -0.101 * 2^-5^ = -0.101 * 2^-101^ 	</font>
<font color='brown'>			阶码转补码变为11,011		尾数转补码变为11.011——>再填充11.01100000		X=11011;11.01100000</font>
<font color='brown'>	59  = 111011B	1/1024 = 2^-10^ ——>Y=+111011 * 2^-10^ = +0.111011 * 2^-4^ = +0.111011 * 2^-100^ </font>
<font color='brown'>			阶码转补码变为11,100		尾数转补码变为00.000101——>再填充00.111011000</font>
<font color='brown'>1.对阶</font> 
<font color='brown'>	①求阶差</font>
	<font color='brown'>		[▲E]~补~ = 110101 + 00100 = 11111，知▲E = -1</font>
<font color='brown'>	②对阶</font>
<font color='brown'>让阶数更小的尾数向右移1位，阶码加1</font>
			<font color='brown'>X=11,011;11.011000000——>11,100;11.101100000	X=-0.0101 * 2 ^-100^ </font>
<font color='brown'>2.尾数加减</font>
		<font color='brown'>-Y=11,100;11.000101000</font>
		<font color='brown'>11.101100000+11.000101000 = 10.110001000</font>
<font color='brown'>3.规格化</font>
		<font color='brown'>X-Y：11,100;10.110001000——>11,100;11.011000100	【尾数的符号位补多少具体应该看最高位的符号位】——>因为右移，因此阶码加1——>11,101;11.011000100</font>
<font color='brown'>4.舍入</font>
		<font color='brown'>无舍入</font>
<font color='brown'>5.判溢出</font>
		<font color='brown'>常阶码，无溢出，结果真值为2^-3^ * (-0.1001111)~2~	【补码还要转换为原码求的真值】</font> 

IEE754时候要保留1.xxx，其他的时候保留0.xxx

----

**<font color='blue'>①只有浮点数才存在舍入、定点数并不存在舍入</font>** 
**<font color='blue'>②右规 以及 对阶【移动尾数导致舍入】 都可能要舍入</font>** 
**<font color='blue'>③对阶操作并不会引起阶码的上溢或下溢</font>** 
**<font color='blue'>④左规时可能引起阶码下溢【阶码减小】</font>** 
**<font color='blue'>⑤右规 和 尾数舍入 时可能引起阶码上溢【阶码变大】</font>** 



### **数据的存储和排列**

​	**大小端方式**
​		大端方式：低地址——>高地址【方便人类阅读】
​		小端方式：高地址——>低地址【方便机器处理】
​			<img src="E:\图片\图床\image-20240228173110236.png" alt="image-20240228173110236" style="zoom:67%;" />
​			
​			![image-20240713211454028](E:\图片\图床\image-20240713211454028.png)

​	**边界对齐**
​		现代计算机按字节编址，即每个字节对应一个地址
​		通常也支持按字、按半字、按字节寻址【寻址都是从0开始】
​		字是可以自定义的长度，字节B固定是8bit

​		因为每次访存只能读/写1个字。
​		当采用边界对齐方式时，访问一个字/半字都只需一次访存。
​		当采用边界不对齐方式时，访问一个字/半字可能要两次访存。
​	   【https://www.bilibili.com/video/BV1ps4y1d73V?t=509.1&p=27】

​		边界对齐方式——空间换时间	

​		边界对齐按字节存储，因此一个字节可以存储2个16进制的数

​      <img src="E:\图片\图床\image-20240228175619428.png" alt="image-20240228175619428" style="zoom:67%;" />

char——8位/1B	short——16位/2B	int——32位/4B	

对于struct类型的长度必须是成员中最大对齐值的整数倍。
![image-20240713212031768](E:\图片\图床\image-20240713212031768.png)		<font color='red'>  sizeof(A)=8		sizeof(B)=12</font >   

A——先放int(4)，下一行再放char(1) 和short(2)
B——先放char(1)，下一行再放int(4)，在下一行放short(2)

### **强制类型转换**

对于32位的机器，char—>int—>long—>double	float—>double 都是无损转换

float—4B	double—8B

不同类似的数混合运算——类型提升（低类型转换为高类型）

int：表示整数，范围-2^31^~2^31^-1，有效数字32位
float：表示整数及小数，范围±[2^-126^~2^127^ * (2-2^-23^)]，<font color='red'>有效数字23+1=24位	</font>
因此从int—>float可能损失精度	float—>int可能溢出及损失精度



# 第三章——存储系统

## 存储器概述

### **多级层次的存储系统**

<img src="E:\图片\图床\image-20240304223444281.png" alt="image-20240304223444281" style="zoom:80%;" />

主存—辅存：实现虚拟存储系统；解决了主存容量不够的问题【辅存的内容必须调入主存后才可被CPU访问】
Cache—主存：解决了主存与CPU速度不匹配的问题

读写宽度
		CPU与各部件之间：字		Cache与主存之间：块		主存与辅存之间：页/段

​            <img src="E:\图片\图床\image-20240304223656371.png" alt="image-20240304223656371" style="zoom:67%;" />		此图为多级存储系统

### **存储器的分类**

1.按层次
		**高速缓存(Cache)**【可直接被CPU读写】
				Cache位于主存和CPU之间，<font color='red'>主要存放当前CPU经常使用的指令和数据</font>，以便CPU能高速访问它们。
				特点：Cache的存取速度和CPU的速度相匹配。容量小、价格高
		**主存储器(主存/内存)**【可直接被CPU读写】
				<font color='red'>主存用来存放计算机运行期间所需的程序和数据</font>。
				CPU可以直接随机地对其进行访问，也可以与Cache和辅存交换数据。
				特点：容量小、存取速度快、价格高
		**辅助存储器(辅存、外存)** 
				辅存主要用来存放暂时不用的程序和数据，以及<font color='red'>一些需要永久性保存的信息</font>。 
				辅存的信息需要调入主存后才能被CPU访问
				特点：容量大、存取速度慢、价格低

2.按存储介质
		半导体存储器(主存、Cache)【以半导体器件存储信息】
		磁表面存储器(磁盘、磁带)【以磁性材料存储信息】
		光存储器(光盘)【以光介质存储信息】

3.按存取方式
		随机存取存储器RAM：读写任意一个存储单元所需时间都相同，与存储单元所在的位置无关【主存、Cache】
		顺序存取存储器SAM：读写一个存储单元所需时间取决于存储单元所在的物理位置【磁带、CD-ROM】
		直接存取存储器DAM：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取
												【磁盘、光盘、机械硬盘】
		相联存储器CAM：按内容访问的存储器。可以按照内容检索到存储位置进行读写。“快表”就是一种相联存储器
										【内容指定方式和地址指定方式相结合】

​		串行访问存储器(SAM、DAM)：读写某个存储单元所需时间与存储单元的物理位置有关

4.按信息的可更改性
		读写存储器：可读、也可写【磁盘、内存、Cache】
		只读存储器ROM：只能读、不能写。信息一旦写入便固定不变，即使断电，内容也不会丢失。
			但是现如今也加入了电擦除等方式来进行写入。
			只读的特性没有保留，但是保留了断电内容保留、随机读取的特性。不过写入速度比读取速度慢。
【实体音乐专辑通常采用CD-ROM、BIOS通常写在ROM中、实体电影采用光碟】

5.按信息的可保存性
		易失性存储器：断电后，存储信息消失的存储器【主存、Cache】
		非易失性存储器：断电后，存储信息依然保持的存储器【磁盘、光盘】

​		破坏性读出——信息读出后，原存储信息被破坏【如DRAM芯片，读出数据后要进行重写】
​				具有破坏性读出性质的存储器， 每次读出后必须紧接一个再生的操作，以便恢复被破坏的信息。
​		非破坏性读出――信息读出后，原存储信息不被破坏【如SRAM芯片、磁盘、光盘】

### **存储器的性能指标**

​	1.存储容量：存储容量= 存储字数*字长【MDR反映存储字长】
​	2.单位成本：每位价格 = 总成本/总容量
​	3.存储速度：数据传输率（每秒传送信息的位数）=  数据的宽度/存储周期【数据的宽度：<font color='red'>存储字长(以B为单位)</font>】

​	存取时间Ta：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间
​	存取周期Tm：存储周期又称为<font color='red'>读写周期或访问周期。</font>它是指存储器进行一次完整的读写操作所需的全部时间，
​							   即连续两次独立地访问存储器操作(读或写操作)之间所需的最小时间间隔

​	主存带宽Bm：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量
​							   单位为字/秒、字节/秒(B/S)、位/秒(b/s)

​				![image-20240307073232220](E:\图片\图床\image-20240307073232220.png) 	 **一般恢复时间>存取时间** 


## 主存储器

### DRAM和SRAM

DRAM（动态RAM）【主存】【使用栅极电容存储信息】
SRAM（静态RAM）【Cache】【使用双稳态触发器存储信息】

静态和动态指的是读出后是否重新，即是否为破坏性读出。

#### 特性差异

<img src="E:\图片\图床\image-20240305222151861-1709732530272.png" alt="image-20240305222151861" style="zoom:67%;" />

#### DRAM的刷新

1.多久刷新一次？					
		刷新周期：一般为2ms
2.每次刷新多少存储单元？	
		以行为单位，每次刷新一行存储单元。由芯片内部自行生成行地址。
3.如何刷新？
		有硬件支持，读出一行的信息后重新写入，占用一个读/写周期。

三种刷新方式：		
	假设DRAM内部结构排列成128*128的形式，读写周期(存取周期)0.5us。则2ms为4000个读/写周期
		**思路一：每次读写完都刷新一行**【分散刷新】
			系统的存取周期变为1us，前0.5us为正常读写，后0.5us为刷新某行。
			优点：<font color='red'>没有死区</font>。
			缺点：加长了系统的存取周期。
		**思路二：2ms内集中安排时间全部刷新**【集中刷新】
			系统的存取周期还是0.5us。有一段时间专门用于刷新，此段时间无法访问存储器，称为访存“死区”。
			优点：读写操作期间不受刷新操作的影响。
			缺点：死区不能访问存储器。
		**思路三：2ms内每行刷新1次即可**【异步刷新】
			2ms内需要产生128次刷新请求，每隔2ms/128 = 15.6us一次，每15.6us内有0.5us的“死时间”【可在译码阶段刷新】

<img src="E:\图片\图床\image-20240305222603220.png" alt="image-20240305222603220" style="zoom:80%;" />

#### DRAM的地址线复用技术

行、列地址分两次送，可使<font color=red>地址线、芯片引脚减半</font>		 

行列地址——减少选通线的数量
		将n位地址，拆分为行地址、列地址(DRAM行、列地址等长)
		存储单元排列成2^n/2^ * 2^n/2^的矩阵
		如2^8^=256根选通线，2^4^+2^4^=32根选通线

DRAM芯片引脚计算：数据引脚+地址引脚+读/写引脚+行/列选信号引脚

 <img src="E:\图片\图床\image-20240305222517489.png" alt="image-20240305222517489" style="zoom: 52%;" />   <img src="E:\图片\图床\image-20240305223311594.png" alt="image-20240305223311594" style="zoom: 51%;" />    

![image-20240307143544040](E:\图片\图床\image-20240307143544040.png) DRAM芯片 4 * 4 * 4——行数、列数、一个超元4位

尽量保证行位数和列位数相同。
又因为按行刷新，所以尽量保证行数较少。

-----

### **只读存储器ROM** 

ROM为非易失性存储器。ROM不需要刷新。
位密度：ROM>DRAM>SRAM

**MROM——掩模式只读存储器**
	厂家按照客户需求，在芯片生产过程中直接写入信息，之后<font color=red>任何人不可重写</font>(只能读出)
	可靠性高、灵活性差、生产周期长、只适合批量定制

**PROM——可编程只读存储器**
	用户可用专门的PROM写入器写入信息，<font color=red>写一次之后就不可更改</font> 

**EPROM——可擦除可编程只读存储器**
	允许用户写入信息，之后用某种方法擦除数据，<font color=red>可进行多次重写</font> 
	不可做为随机存储器——编程次数有限，写入时间长

**Flash——闪速存储器**【U盘、SD卡就是闪存】
	在EEPROM基础上发展而来，断电后也能保存信息，且<font color=red>可进行多次快速擦除重写</font> 
	注意：由于闪存需要先擦除再写入，<font color=red>因此闪存的“写”速度要比“读”速度更慢。</font>  

**SSD——固态硬盘**
	由控制单元+存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，<font color=red>可进行多次快速擦除重写</font>。SSD速度快、功耗低、价格高。目前个人电脑常用SSD取代传统的机械硬盘

**PS：计算机中重要的RAM：** 
	操作系统安装在辅存之中
	CPU的任务：到主存中取指令并执行指令
	主板上的BIOS芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）
	逻辑上，主存由RAM+ROM组成，且二者常**统一编址** 

### **主存储器的基本组成**

存储体由存储单元组成。存储单元由存储元组成。每个存储元存储一个比特位。
在同一寄存器中，每个存储单元的宽度必须相同。（即每个存储单元存储的比特位必须相同）

主存由RAM和ROM组成。二者统一编址。

<img src="E:\图片\图床\image-20240305104518306.png" alt="image-20240305104518306" style="zoom: 63%;" /> 存储体也可称为存储矩阵

​	**存储器芯片的基本原理**
​		**译码器**
​			作用：根据地址来决定，读/写哪一个存储字
​			工作流程：根据来自MAR给出的地址，把其转变为某一条选通线的高电平信号【即给该字选线高电平的输出】
​								从而使得该线的存储字对应的存储元件都被选通，就可读出每一位的二进制数据 
​								当字选线被接通后，可根据数据线(位线)，将每一位的二进制信息传递到MDR中
​								CPU会通过数据总线，从MDR中取走这一整个字的数据。【数据总线宽度 = 存储字长】

​				每一个地址对应译码器的一条输出线【MAR的位数反映了地址数】
​				n位地址——>2^n^个存储单元				

​		**控制电路**
​			作用：控制译码器、MAR、MDR【例：CPU通过地址总线把地址送到MAR中。但只有MAR稳定后才能送入译码器中。当MAR稳定后，控制电路打开开关，让MAR送入译码器中】
​					【例：只有当输出信息稳定，才认为输出信息无误，控制MDR，控制什么时候给数据总线送出数据】

​		**片选线**		**CS(芯片选择信号)、CE(芯片使能信号)	**	
​				<img src="E:\图片\图床\image-20240305113057264.png" alt="image-20240305113057264" style="zoom:67%;" /> 	头上划线表示该信号低电平有效

​		**读控制线/写控制线**
​			两根读/写线
​					<img src="E:\图片\图床\image-20240305113357905.png" alt="image-20240305113357905" style="zoom:67%;" />允许写		<img src="E:\图片\图床\image-20240305113413410.png" alt="image-20240305113413410" style="zoom:67%;" />允许读	【WE】

​			一根读/写线
​					<img src="E:\图片\图床\image-20240305113357905.png" alt="image-20240305113357905" style="zoom:67%;" /> 高电平读，低电平写

<img src="E:\图片\图床\17.png" alt="17" style="zoom: 50%;" />

​    						   <img src="E:\图片\图床\image-20240305114400435.png" alt="image-20240305114400435" style="zoom:67%;" /> 图中的每根线都会对应一个金属引脚

​							<font color='red'>数据线=数据位数 </font> 【存储单元为16位——>数据线是16位】
​							<font color='red'>地址线=log~2~(寻址范围)	【如：1024*8	数据线为8根，地址线为10根】</font > 

驱动器：保证译码器输出的电信号是稳定有效的

引脚数量：数据线+地址线+片选线（最少为1）+读写控制线（1/2）

### **多模块存储器** 

为了提升主存速度——双端口RAM和多模块存储器

#### 多模块存储器

多模块存储器属于空间并行技术

多模块存储器之所以可以提高存储器的访问速度，因为各模块有独立的读/写电路

##### **多体并行存储器** 

每个存储模块都有相同的容量和存取的速度
各模块都有独立的读写控制电路、地址寄存器和数据寄存器。他们既能并行工作，又能交叉工作

体号——M~0~,M~1~等
体内地址——M~0~或M~1~中的存储单元的地址

**高位交叉编址：体号+体内地址** 【体号高位】

<img src="E:\图片\图床\image-20240306095225207.png" alt="image-20240306095225207" style="zoom:67%;" />

​		地址编号为从M~0~的竖行开始【不满足局部性原理】

**低位交叉编址：体内地址+体号**

<img src="E:\图片\图床\image-20240306095249497.png" alt="image-20240306095249497" style="zoom:67%;" />

​		地址编号为从M~0~—>M~1~—>M~2~—>M~3~的横行开始【满足局部性原理】

----

若每个存储体存取周期为T，存取时间为r，假设T=4r，连续访问：00000	00001	00010	00011	00100

![image-20240306095550984](E:\图片\图床\image-20240306095550984.png)	连续读取n个存储字：耗时nT

![image-20240726180449727](E:\图片\图床\image-20240726180449727.png)连续存取n个存储字：耗时T+(n-1)r【具体画甘特图】

-----

采用流水线的方式并行存取（宏观上并行，微观上串行）
宏观上，一个存取周期内，m体交叉存储器可以提供的数据量为单个模块的m倍
<font color='red'>存取周期为T，存取时间为t，为了使流水线不间断，应保证模块数m≥T/r</font>	<font color='red'>【存取时间 也可称为 总线传输时间】</font>  

----

![image-20240307110652923](E:\图片\图床\image-20240307110652923.png)

 ![image-20240307110710403](E:\图片\图床\image-20240307110710403.png) 2.25T与2.75T是最后一次的，套用公式T+(n-1)*4/T

----

 <img src="E:\图片\图床\image-20240307111947353.png" alt="image-20240307111947353" style="zoom:50%;" />   芯片数为4

##### 单体多字存储器

每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字

每次只能同时取m个字，不能单独取其中某个字。
指令和数据在内存中必须是连续存放的。

缺点：只有指令和数据在主存中连续存放时，此方法才能有效提升存取速度。
			一旦遇到转移指令，或操作数不能连续存放时，此方法提升效果不明显。



### **寻址** 

​	总容量为1KB、字长为4B
​		按字节寻址：1K个单元，每个单元1B【10根地址线】
​		按字寻址：256单元，每个单元4B【8根地址线】
​		按半字寻址：512单元，每个单元2B
​		按双字寻址：128单元，每个单元8B

## 主存储器与CPU的连接

数据总线(宽度=存储字长)

字扩展——扩展主存字数

位扩展——解决 数据总线宽度>存储芯片字长 的问题

<img src="E:\图片\图床\image-20240306112126620.png" alt="image-20240306112126620" style="zoom: 67%;" />现在的计算机【主存中含多块存储芯片】

### **存储器芯片的输入输出信号**

<img src="E:\图片\图床\image-20240306112326375.png" alt="image-20240306112326375" style="zoom:67%;" />



#### 位扩展

​	作用：增加主存的存储字长

<img src="E:\图片\图床\image-20240306113013819.png" alt="image-20240306113013819" style="zoom:67%;" />



<img src="E:\图片\图床\image-20240306113121754.png" alt="image-20240306113121754" style="zoom:67%;" />

#### 字扩展

​	作用：增加主存的存储字数

##### 线选法

 A~13~ A~14~只能为01或10，n条线——>n个片选信号【n条多余的线】	【因为只能01、10，因此地址空间不连续】

<img src="E:\图片\图床\image-20240306142657386.png" alt="image-20240306142657386" style="zoom:67%;" />

##### 译码器片选法

n条线——>2^n^个片选信号

【1-2译码器、2-4译码器、3-8译码器】2^n^ 

<img src="E:\图片\图床\image-20240306143206883.png" alt="image-20240306143206883" style="zoom:67%;" />

-------

<img src="E:\图片\图床\image-20240307175404477.png" alt="image-20240307175404477" style="zoom:67%;" />

----

### **字位同时扩展**

前面D~0~ ~ D~3~ ，后面D~4~ ~ D~7~ 

![image-20240307175913510](E:\图片\图床\image-20240307175913510.png)



### **译码器** 

​				<img src="E:\图片\图床\image-20240307180116326.png" alt="image-20240307180116326" style="zoom:53%;" />    								<img src="E:\图片\图床\image-20240307180439577.png" alt="image-20240307180439577" style="zoom:50%;" />



EN，使能端，使译码器能够工作，类似于CS
多个使能端（只有当多个使能端都同时生效的时候，译码器才可以工作）
CPU可使用译码器的使能端控制片选信号的生效时间



74ls138译码器		<img src="E:\图片\图床\image-20240307182147231.png" alt="image-20240307182147231" style="zoom:50%;" />

CPU的输出信号![image-20240307182244421](E:\图片\图床\image-20240307182244421.png) ，当CPU想要访问主存的时候，就会使这个信号有效。当CPU没有发出![image-20240307182244421](E:\图片\图床\image-20240307182244421.png) 信号的时候，
![image-20240307182405866](E:\图片\图床\image-20240307182405866.png) 为1，译码器不工作，使得所有译码器输出都是1，没有任何一个存储芯片被选通。当发出![image-20240307182244421](E:\图片\图床\image-20240307182244421.png)信号的时候，![image-20240307182405866](E:\图片\图床\image-20240307182405866.png)接受到此信号，才会把CBA处的地址信号映射为某一位的选通信号。

CPU先通过地址线送出地址信号（包括A~0~ ~ A~12~和CBA）.CPU刚开始输出电信号的时候，电信号可能不稳定，因此需要等电流稳点之后发出![image-20240307182244421](E:\图片\图床\image-20240307182244421.png) ，让译码器的某一个选通线有效。



 RAM的读写周期		![image-20240307182837692](E:\图片\图床\image-20240307182837692.png)	



## 外部存储器

计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。

读写数据都是以1bit为单位的【读写操作不能同时进行】

磁表面存储器优点：
	①存储容量大，位价格低;
	②记录介质可以重复使用;
	③记录信息可以长期保存而不丢失，甚至可以脱机存档;
	④非破坏性读出，读出时不需要再生。

磁表面存储器缺点：
	①存取速度慢
	②机械结构复杂
	③对工作环境要求较高

### **磁盘存储器**

**1.磁盘设备的组成**
	①存储区域
		一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，<font color='red'>扇区（也称块）是磁盘读写的最小单位</font>，也就是说磁盘按块存取。

![image-20240307233652108](E:\图片\图床\image-20240307233652108.png)

​	②硬盘存储器
​		硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成

​		磁盘驱动器：驱动磁盘转动并在盘面上通过磁头进行读/写操作【温彻斯特盘】
​		磁盘控制器：是硬盘存储器和主机的接口。负责接受并解释CPU发来的命令，向磁盘驱动器发出各种控制信号。

**2.磁盘的性能指标**
	①磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。
			非格式化容量：磁记录表面可以利用的磁化单元总数
			格式化容量：按照某种特定的记录格式所能存储信息的总量
			<font color='red'>非格式化容量>格式化容量</font>

​	②记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。
​			道密度：沿磁盘半径方向单位长度上的磁道数;
​			位密度：磁道单位长度上能记录的二进制代码位数;
​			面密度：位密度和道密度的乘积。

​			ps：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。
​					越内侧的磁道位密度越大

​	③平均存取时间：
​			平均存取时间=寻道时间（磁头移动到目的磁道）+		
​										旋转延迟时间（磁头定位到所在扇区）+		<font color='red'>【一般为转半圈所需的时间】</font> 
​										传输时间（传输数据所花费的时间)
​			ps：可能还有再加上 磁盘控制器延迟时间

​	④数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数
​			假设磁盘转数为r (转/秒)，每条磁道容量为N个字节，则数据传输率为D~r~ = rN			

**3.磁盘地址**
	主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示：
		![image-20240307235253765](E:\图片\图床\image-20240307235253765.png)

![image-20240307235347283](E:\图片\图床\image-20240307235347283.png)

**4.磁盘的工作过程** 
	硬盘的主要操作是寻址、读盘、写盘。
	每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。
	硬盘属于机械部件，<font color='red'>其读写操作是串行的</font>，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据

---

①磁盘的有效存储区域是从内半径到外半径，这一段区域

### **磁盘阵列** 

​	RAID(廉价冗余磁盘阵列)是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上<font color='red'>分割交叉存储、并行访问</font>，具有更好的存储性能、可靠性和安全性。

​	RAID的分级如下所示。在RAID1～RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。

RAID0:无冗余和无校验的磁盘阵列
	【逻辑上相邻的两个扇区在物理上存到两个磁盘，类比第三章“低位交叉编址的多体存储器”】
	【RAIDO把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。】
RAID1:镜像磁盘阵列
	【很粗暴，存两份数据，容量减少一半】
RAID2:采用纠错的海明码的磁盘阵列
	【逻辑上连续的几个bit物理上分散存储在各个盘中4bit信息位+3bit海明校验位一一可纠正一位错】
RAID3:位交叉奇偶校验的磁盘阵列
RAID4:块交叉奇偶校验的磁盘阵列
RAID5:无独立校验的奇偶校验磁盘阵列

 <img src="E:\图片\图床\image-20240307235907284.png" alt="image-20240307235907284" style="zoom:50%;" />  			  <img src="E:\图片\图床\image-20240308000026180.png" alt="image-20240308000026180" style="zoom:50%;" />  		<img src="E:\图片\图床\image-20240308000214950.png" alt="image-20240308000214950" style="zoom:50%;" />

RAID通过同时使用多个磁盘，提高了传输率；
通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；
通过镜像功能，可以提高安全可靠性。通过数据校验，可以提供容错能力。

### **固态硬盘SSD** 

原理：基于闪存Flash，属于电可擦除ROM
以**页**为单位进行读/写。以**块**为单位进行擦除。
支持随机访问。读块，写慢。
固态硬盘一个块若被多次擦除/重复写同一个块，可能会坏掉。而机械硬盘的扇区不会因为写多次而坏掉。

## Cache

### **Cache工作原理**

![image-20240308103014850](E:\图片\图床\image-20240308103014850.png)

实际上，Cache被集成在CPU内部。Cache用SRAM实现，速度快，成本高，集成度低

空间局部性：在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的(顺序执行)
时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息
若程序按“列优先”访问二维数组，空间局部性更差

基于程序的局部性原理，可以把CPU目前访问的地址<font color='red'>“周围”</font>的部分数据放到Cache中
		局部性原理：在程序的执行过程中，程序对主存的访问是不均匀的。

​	“周围”如何确定：将主存的存储空间“分块”。主存与Cache之间以“块”为单位进行数据交换
 	主存的地址分为：块号 块内地址【块号——>块数，块内地址——>每块大小】
​	 操作系统中，通常将主存中的一个“<font color='red'>块</font>”也称为一个<font color='red'>页/页面/页框</font> 
​	 Cache中的“<font color='red'>块</font>”也称为“<font color='red'>行</font>” 【<font color='red'>**Cache块与主存块的大小相等**</font>】
​		每次被访问的主存块，一定会被立即调入Cache(复制数据并不是删除数据)

### **性能分析**

设t~c~为访问一次Cache所需时间，t~m~为访问一次主存所需时间

命中率H：CPU欲访问的信息已在Cache中的比率
缺失（未命中）率M =1-H
Cache—主存系统的平均访问时间t = H * t~c~ + (1-H)(t~c~ + t~m~)【先访问Cache，若Cache未命中再访问主存】
															t = H * t~c~ + (1-H)t~m~【Cache和主存同时访问】



### **Cache—主存的映射方式**

**全相联映射** 
	主存块可以放在Cache的任意位置

​	如何区分Cache中存放的是哪个主存块?
​			给每个cache块增加一个<font color='red'>“标记”</font>，记录对应的主存块号	【<font color='red'>标记的位数就是主存块号的位数</font>】
​			<font color='red'>有效位</font>：有效位为1——标记有效，有效位为0——标记无效

 				![image-20240309095920219](E:\图片\图床\image-20240309095920219.png)

​	CPU访问主存地址 <font color='brown'>1…1101</font> <font color='blue'>001110</font>
​	访存过程：①主存地址的前X位，对比Cache中所有块的标记;	【x为主存块号的位数】
​						②若标记匹配且有效位=1，则Cache命中，访问块内地址为001110的单元。
​						③若未命中或有效位=0，则正常访问主存

​	优点：Cache存储空间利用充分，命中率高
​	缺点︰查找“标记"最慢，有可能需要对比所有行的标记

**直接映射**
	每个主存块只能放到一个特定的位置：Cache块号 = 主存块号 % Cache总块数	
	标记的优化：若Cache总块数=2^n^ 则主存块号末尾n位直接反映它在Cache中的位置，<font color='red'>因此标记可以省去末尾的n位</font> 

 <img src="E:\图片\图床\image-20240308115547308.png" alt="image-20240308115547308" style="zoom:50%;" />

CPU访问主存地址<font color='brown'>0...01</font><font color='blue'>000</font> <font color='orange'>001110 </font>
访存过程：①根据主存块号的后3位确定Cache行
					②若主存块号的前19位与Cache标记匹配且有效位=1，则Cache命中，访问块内地址为001110的单元。
					③若未命中或有效位=0，则正常访问主存

优点：对于任意一个地址，只需对比一个“标记”，速度最快
缺点： Cache存储空间利用不充分，命中率低

**组相联映射**
	Cache块分为若干组，每个主存块可放到特定分组中的任意一个位置
	组号 = 主存块号 % 分组数

 <img src="E:\图片\图床\image-20240308120137736.png" alt="image-20240308120137736" style="zoom:50%;" />

​	主存块号的末尾2位，反映了组号。因此标记位取前20位即可
​	
​	CPU访问主存地址<font color='brown'>1...11</font><font color='blue'>01</font> <font color='orange'>001110 </font> 
​	访存过程：①根据主存块号的后2位确定所属分组号
​						②若主存块号的前20位与分组内的某个标记匹配且有效位=1,则cache命中，访问块内地址为001110的单元
​						③若未命中或有效位=0，则正常访问主存

​	优点:另外两种方式的折中，综合效果较好

​	2路组相联映射――2块为一组

<img src="E:\图片\图床\image-20240308113314410.png" alt="image-20240308113314410" style="zoom: 50%;" />

### **Cache替换算法**

**全相联映射** 
	Cache完全满了以后才需要替换，需要在全局选择替换哪一块
**直接映射**
	如果对应位置非空，则毫无选择地直接替换【无需考虑替换算法】
**组相联映射**
	分组内满了才需要替换，需要在分组内选择替换哪一块

因此只有全相联映射和组相联映射才考虑替换算法，直接映射直接替换

#### 随机算法RAND

若Cache已满，则随机选择完一块替换

实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定

#### 先进先出算法FIFO

若Cache已满，则替换最先被调入Cache的块

设总共有4个Cache块，初始整个Cache为空。采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}

![image-20240308151231495](E:\图片\图床\image-20240308151231495.png)

实现简单，最开始按0 1 2 3放入Cache，之后轮流替换0 1 2 3
FIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的

抖动现象：频繁的换入换出现象（刚被替换的块很快又被调入)

#### 最近最少使用LRU

为每一个Cache块设置一个“计数器”，用于记录每个Cache块已经有多久没被访问了。当Cache满后替换“<font color='red'>计数器</font>”最大的。
**<font color='red'>往前看</font>** 

**<font color='orange'>Cache块的总数=2^n^，则计数器只需n位</font>** 

①命中时，所命中的行的计数器清赛，比其低的计数器加1，其余不变;
②未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1;
③未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。

<font color='red'>LRU基于“局部性原理”</font>，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。

若被频繁访问的主存块数量 > Cache行的数量，则有可能发生“抖动”，如: {1,2,3,4,5,1,2,3,4,5,1,2}

![image-20240308155114351](E:\图片\图床\image-20240308155114351.png)

#### 最近不经常使用LFU

为每一个Cache块设置一个“计数器”，用于记录每个cache块被访问过几次。当Cache满后替换“计数器”最小的

 <font color='orange'>**计数器的数值不确定，因此给计数器的位数需要很大才可以**</font> 

曾经被经常访问的主存块在未来不一定会用到（如:微信视频聊天相关的块)并没有很好地遵循局部性原理，因此实际运行效果不如LRU

![image-20240308155048188](E:\图片\图床\image-20240308155048188.png)

新调入的块计数器=0，之后每被访问一次计数器+1。需要替换时，选择计数器最小的一行。无清零操作。



### **Cache写策略**

​	作用：若CPU修改了Cache中的数据副本，确保主存中数据母本的一致性

​	读操作不会导致cache和主存的数据不一致

#### **写命中**

**回写法**
	当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被替换时才写回主存

​	<font color='red'>脏位</font>：表示是否被修改过【脏位为1—已修改 		脏位为0—未修改】

​	减少了访存次数，但存在数据不一致的隐患

**直写法**
	当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用<font color='red'>写缓冲</font> 

​		写缓冲：由SRAM实现的FIFO队列。【使用写缓冲，CPU写的速度很快】
​				若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞			
​		CPU将数据写入Cache和写缓冲，当CPU干别的事情的时候，在专门的控制电路控制下，把写缓冲逐一写回主存。
​		CPU---->cache+写缓冲---->主存

​	访存次数增加，速度变慢，但更能保证数据一致性

#### **写不命中**

**写分配法**
	当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。<font color='red'>通常搭配写回法使用</font>。【先调后写】

**非写分配法** 
	当CPU对Cache写不命中时，只写入主存，不调入Cache。搭配全写法使用。	
			<font color='red'>只有当“读操作”未命中时，才调入Cache。写操作会直接写，并不会调入Cache</font>。

#### 多级Cache

现代计算机常采用多级Cache
	离CPU越近的速度越快，容量越小
	离CPU越远的速度越慢，容量越大

Cache-主存之间常采用“写回法+写分配法”
各级cache之间常采用“全写法+非写分配法”	【cache写更快】	

**<font color='orange'>Cache的标记项——(有效位、脏位、替换算法位、标记位)[行号/块号]  块内地址</font>**   

分离指令Cache和数据Cache优点：充分利用指令和数据的不同局部性来优化性能。

### **强化** 

Cache大题需要注意的条件：
	①物理地址位数【地址总位数】
	②Cache总行数	③Cache块大小	【得出Cache数据区的总大小】【块内地址的大小以B为单位(以字节编址)】
	④Cache的映射方式
	⑤写策略 
	⑥替换算法

Cache行的组成：
	①标记位	②有效位【必存在】	
	③替换算法位【随机替换：0bit。直接映射：0bit。全相联映射/组相联映射：log~2~行数/路数(LRU或FIFO)】
	④脏位【回写法才存在】
	⑤块内数据大小
	Cache容量=Cache行组成 * 行数。
	标记阵列/地址映射表容量=行数 *（①+②+③+④）【标记阵列的每一行都有一个标记项】

TLB表项的构成：【与虚地址大小有关】
	①虚页号【虚页号根据映射方式的不同，划分不同】
					【全相联：Tag位数与虚页号相同。组相联：虚页号=Tag+组号。直接映射：虚页号=Tag+行号】
	②有效位【必存在1bit】
	③页框号(物理块号)【与页大小有关】
	④替换信息位【与上述相同】	
	PS：TLB中无脏位

比较器：
	直接映射：一个比较器。
	全相联映射：Cache的每一行都设置一个比较器，比较器位数等于标记字段的位数。
	组相联映射：r路组相联。r为比较器数。

零碎知识点：
	①主存地址空间大小=标记位+行号/组号+块内地址
	②主存容量有x块。x=标记位+行号。
	③映射表是一个相联存储器。
	④PCB、页表在主存中，页表始址在PCB中
	⑤Cache在CPU中
	⑥直接映射和组相联映射关于二维数组的行列优先的Cache命中率不同
		直接映射的列优先命中率基本为0
		组相联映射的列优先命中率需要具体分析

## 虚拟存储器 

主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。
虚拟存储器具有主存的速度和辅存的容量。

cache全由硬件实现，是硬件存储器，对所有程序员透明
虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明。

### **基本概念** 

虚拟存储器将主存或辅存的地址空间**统一编制**。

虚地址/逻辑地址：用户编程允许涉及的地址。
虚拟空间/程序空间：虚地址对应的存储空间。
实地址/物理地址：实际的主存单元地址。
主存地址空间/实地址空间：实地址对应的存储空间。

CPU使用虚地址时，先判断这个虚地址是否已经装入主存。
	若已装入主存，则通过地址变换，CPU可直接访问主存指示的实际单元。
	若不在主存，则把包含这个字的一页或一段调入主存后再由CPU访问。
	若主存已满，则采用替换算法置换主存中的页面。

实地址=主存页号+页内字地址
虚地址=虚存页号+页内字地址
辅存地址=磁盘号+盘面号+磁道号+扇区号

虚拟存取器采用<font color='red'>全相联映射</font>和<font color='red'>回写法</font>。

### **页式虚拟存储器** 

#### 页式存储

页面存储系统：一个**程序**(进程)在逻辑上被划分为若干个大小相等的页面。<font color='red'>页面的大小于块的大小相同</font>。
								每个页面可以<font color='red'>离散</font>地放入不同的主存块中。

逻辑地址：<img src="E:\图片\图床\image-20240822154222737.png" alt="image-20240822154222737" style="zoom:45%;" />物理地址：<img src="E:\图片\图床\image-20240822154238837.png" alt="image-20240822154238837" style="zoom:50%;" />

页表：记录了每个逻辑页面存放到哪个主存块中【页表存放在主存中，因此查询页表就要进行一次访存操作】
页表基址寄存器：指明了页表在主存中的存放地址		
快表TLB：TLB标记位+页框号【地址空间大小看虚拟地址空间大小】【相联存储器】【不需要访存】
					TLB标记位=虚拟地址的虚页号位数		页框号位数=物理地址的页框位
		<font color='orange'>页表由DRAM组成，快表由SRAM组成</font> 
		<font color='orange'>快表是一种特殊的Cache</font> 

<img src="E:\图片\图床\image-20240822170041975.png" alt="image-20240822170041975" style="zoom:50%;" />

#### **页式虚拟存储器**

页式虚拟存储器以页为基本单	位。
主存空间和虚拟空间都被划分为大小相同的页面。

 <img src="E:\图片\图床\image-20240822160739893.png" alt="image-20240822160739893" style="zoom: 70%;" />  <img src="E:\图片\图床\image-20240822160811148.png" alt="image-20240822160811148" style="zoom:80%;" />

优点：页面长度固定、页表简单、调入方便
缺点：①程序不可能正好是页面的整数倍。因此会有外部碎片。
			 ②页不是独立的实体。处理、保护、共享不如段式虚拟存储器方便。

### **段式虚拟存储器** 

按照功能模块将程序拆分为若干个段。【段的大小可以不同】

<img src="E:\图片\图床\image-20240822161031700.png" alt="image-20240822161031700" style="zoom: 67%;" />

### **段页式虚拟存储器** 

将程序按逻辑分段，每段再划分为固定大小的页。
主存空间也划分为大小相等的页。
程序对主存的调入、调出仍以页为基本单位。
每个程序对应一个段表，每个段表对应一个页表。

虚拟地址：段号+段内页号+页内地址

分页管理——内部碎片
分段管理——外部碎片
段页式——内部碎片+外部碎片




# 第四章——指令系统

## 指令格式

指令：是指示计算机执行某种操作的命令，<font color='red'>是计算机运行的最小功能单位</font>。 

一台计算机的所有系统指令的集合构成该机的**指令系统**，也称为**指令集**。 
一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。
不同系统的计算机，所能支持的指令集不同

指令系统是指令集体系结构ISA中最核心的部分。
<font color='red'>ISA中记录了</font>①指令格式、指令寻址方式、操作类型
					  ②操作数类型、操作数寻址方式、大端/小端
					  ③程序可访问的寄存器编号、个数和位数。
					  ④存储空间大小和编制方式
					  ⑤指令执行过程的控制方式等。包括PC和条件码定义等。

一条指令通常要包括操作码字段（OP）和地址码字段（A）两部分

### **分类**

#### 按地址码数目不同分类

一条指令可能包含0个、1个、2个、3个、4个地址码..
根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令...

n位地址码的直接寻址范围=2^n^ ，若指令总长度固定不变，则地址码数量越多，寻址能力越差

##### **零地址指令**

1.不需要操作数，如**空操作、停机、关中断**等指令	【操作数：参与运算的数据】
2.堆栈计算机，两个操作数隐含存放在<font color='orange'>**栈顶和次栈顶**</font>，计算结果压回栈顶。

<font color='red'>只有操作码，取值后PC+1</font> 

##### **一地址指令**

1.只需要单操作数，如加1、减1、取反、求补等
		指令含义：OP(A~1~)→A~1~ 			【<font color='red'>三次访存：取指—>读A~1~—>写A~1~ </font>】
2.需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）
		指令含义：(ACC)OP(A1)→ACC	【<font color='red'>两次访存：取指→读A~1~ </font>】	【**存结果这个过程，不需要访存**】

 	<img src="E:\图片\图床\image-20240309183226745.png" alt="image-20240309183226745" style="zoom:67%;" />

【A~1~指某个主存地址，(A~1~)表示A~1~所指向的地址中的内容】

##### **二地址指令**

常用于需要两个操作数的算术运算、逻辑运算相关指令
		指令含义：(A~1~)OP(A~2~)→A~1~		【<font color='red'>四次访存：取指—>读A~1~—>读A~2~—>写A~1~ </font>】

 	<img src="E:\图片\图床\image-20240309182455265.png" alt="image-20240309182455265" style="zoom:67%;" />

##### 三地址指令

常用于需要两个操作数的算术运算、逻辑运算相关指令
		指令含义：(A~1~)OP(A~2~)→A~3~ 		【<font color='red'>四次访存：取指—>读A~1~—>读A~2~—>写A~3~ </font>】

 	<img src="E:\图片\图床\image-20240309182524571.png" alt="image-20240309182524571" style="zoom:67%;" />

##### 四地址指令

指令含义：(A~1~)OP(A~2~)→A~3~，A~4~=下一条将要执行指令的地址	【<font color='red'>四次访存：取指—>读A~1~—>读A~2~—>写A~3~ </font>】

 	<img src="E:\图片\图床\image-20240309182839696.png" alt="image-20240309182839696" style="zoom:67%;" />

正常情况下：取指令之后PC+1，指向下一条指令
四地址指令：执行指令后，将PC的值修改为A~4~所指地址

#### 按指令长度分类

指令字长：一条指令的总长度（可能会变)【<font color='red'>指令字长为编址长度的整数倍</font>】
机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关)
存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）

半字长指令、单字长指令、双字长指令——指令长度是机器字长的多少倍

<font color='red'>指令字长会影响取指令所需时间</font>。如：机器字长=存储字长=16bit，则取一条双字长指令需要两次访存

**定长指令字结构**：指令系统中所有指令的长度都相等
**变长指令字结构**：指令系统中各种指令的长度不等

#### 按操作码长度分类

**定长操作码**：指令系统中所有指令的操作码长度都相同	【n位→2^n^条指令】
				 优点：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利;
				 缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。灵活性低。
**可变长操作码**：指令系统中各指令的操作码长度可变
				优点：在指令字长有限的前提下仍保持比较丰富的指令种类。灵活性高。
				缺点：增加了指令译码和分析的难度，使控制器的设计复杂化。

#### 按操作类型分类 

**1.数据传送**
		LOAD	作用：把存储器中的数据放到寄存器中
		STORE	作用：把寄存器中的数据放到存储器中

​		<font color='red'>数据传送类：完成了主存与CPU之间的数据传送</font> 

**2.算术逻辑操作**
		算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算
		逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

**3.移位操作** 
		算术移位、逻辑移位、循环移位(带进位和不带进位)

**4.转移操作** 
		无条件转移——JMP
		条件转移——Jz：结果为0；    JO：结果溢出；    JC：结果有进位
		调用和返回——CALL和RETURN
		陷阱(Trap)与陷阱指令
		循环

​		<font color='red'>程序控制类：改变程序执行的顺序，即改变程序执行流</font> 
​		<font color='red'>转移操作都会导致PC值的改变</font> 

**5.输入输出操作**
		CPU寄存器与端口之间的数据传送（端口即IO接口中的寄存器）

​		<font color='red'>输入与输出类：进行CPU与I/O设备之间的数据传送</font> 

### **扩展操作码指令**

​	**定长指令字结构+可变长操作码→扩展操作码指令格式** 【不同地址数的指令使用不同长度的操作码】

<font color='red'>**举例1**</font> 

指令字长为16位，每个地址码占4位:
前4位为基本操作码字段OP，另有3个4位长的地址字段A~1~、A~2~和A~3~。

4位基本操作码若全部用于三地址指令，则有16条。
但至少须将1111留作扩展操作码之用，即三地址指令为15条;

1111 1111留作扩展操作码之用，二地址指令为15条;

1111 1111 1111留作扩展操作码之用，一地址指令为15条;

零地址指令为16条。

 <img src="E:\图片\图床\image-20240309195656528.png" alt="image-20240309195656528" style="zoom: 80%;" />

在设计扩展操作码指令格式时，必须注意以下两点:
	①不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同
	②各指令的操作码一定不能重复。

对使用频率较高的指令，分配较短的操作码。
对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

**<font color='red'>举例二</font>** 

![image-20240309201802502](E:\图片\图床\image-20240309201802502.png)

15条——>0~14
12条——>0~11							
62条——>0~61							
32条——>0~31

<font color='red'>设地址长度为n，上一层留出m种状态，下一层可扩展出m×2^n^种状态</font> 

<font color='blue'>**①中断隐指令不属于程序控制类指令**</font>。

## 指令的寻址方式

### 指令寻址

指令寻址：寻找下一条欲执行指令的地址【**始终由程序计数器PC给出**】【**指令始终在主存中**】

#### **顺序寻址**

**举例1**

该系统采用定长指令字结构
指令字长=存储字长=16bit=2B
**主存按字编制**
	这种情况(PC) + 1—>PC	【PC加1】

该系统采用定长指令字结构
指令字长=存储字长=16bit=2B
**主存按字节编制**
	这种情况(PC) + 2—>PC	【PC加2】

**举例2**

该系统采用**变长指令字结构**
指令字长=存储字长=16bit=2B
**主存按字节编址**

①读入一个字，根据操作码判断这条指令的总字节数n，修改PC的值（ (PC)+n—>PC）	
		【每次取指令结束后，PC+"1"】此1为一个指令字长
②根据指令的类型，CPU可能还要进行多次访存，每次读入一个字

#### **跳跃寻址**

跳跃寻址，由转移指令指出。
	绝对跳跃——地址码直接给出地址
	相对跳跃——跳跃基于当前PC的偏移量

**举例1**

该系统采用定长指令字结构
指令字长=存储字长=16bit=2B
**主存按字编制**

每取走一个指令，PC+1，同时CPU执行当前指令。CPU取PC所指指令，PC+1，同时CPU执行当前指令。……

当CPU取到转移指令时，PC仍+1，然后再把PC内容变为转移指令所指的地址

### **数据寻址** 

数据寻址：确定本条指令的地址码指明的真实地址

![image-20240309230322854](E:\图片\图床\image-20240309230322854.png)

```
下列	假设指令字长 = 机器字长 = 存储字长，操作数为3
```

#### 直接寻址

直接寻址：指令字中的形式地址A就是操作数的真实地址EA，即EA=A 【A为无符号数】

<img src="E:\图片\图床\image-20240309230500008.png" alt="image-20240309230500008" style="zoom:50%;" />  	访存2次：取指令访存1次、执行指令访存1次、暂不考虑存结果

优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。
缺点：A的位数决定了该指令操作数的寻址范围。操作数的地址不易修改。

#### 间接寻址

间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，
					也就是操作数地址的地址，即EA=(A)。【A为无符号数】

主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址；
主存字第一位为0时，表示取得的是操作数的【地址】

<img src="E:\图片\图床\image-20240309230815039.png" alt="image-20240309230815039" style="zoom:67%;" />         访存3次：取指令访存1次、执行指令访存2次、暂不考虑存结果

<img src="E:\图片\图床\image-20240309230959700.png" alt="image-20240309230959700" style="zoom:67%;" />		访存4次：取指令访存1次、执行指令访存3次、暂不考虑存结果

优点：可扩大寻址范围(有效地址EA的位数大于形式地址A的位数)。
			 便于编制程序(用间接寻址可以方便地完成子程序返回)。
缺点：指令在执行阶段要多次访存(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。

#### 寄存器寻址

寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即EA =R~i~，其操作数在由R~i~所指的寄存器内。
						<font color='red'>**操作数就在寄存器中**</font> 

 <img src="E:\图片\图床\image-20240309231304141.png" alt="image-20240309231304141" style="zoom: 50%;" />访存1次：取指令1次、执行指令0次、暂不考虑存结果【因为执行指令访问寄存器，不访问主存】

优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。
缺点：寄存器价格昂贵，计算机中寄存器个数有限。

#### 寄存器间接寻址

寄存器间接寻址：寄存器R~i~中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R~i~)。

 <img src="E:\图片\图床\image-20240309231555841.png" alt="image-20240309231555841" style="zoom:67%;" />  访存2次：取指令访存1次、执行指令访存1次、暂不考虑存结果

优点：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)。

#### 隐含寻址

隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。

 <img src="E:\图片\图床\image-20240309231747809.png" alt="image-20240309231747809" style="zoom:67%;" /> 

优点：有利于缩短指令字长。
缺点：需增加存储操作数或隐含地址的硬件。

#### 立即寻址

立即寻址：形式地址A就是操作数本身，又称为立即数，**一般采用补码形式**。
					<font color='orange'>**# 表示立即寻址特征**</font>。

 <img src="E:\图片\图床\image-20240309233548029.png" alt="image-20240309233548029" style="zoom:50%;" />	访存1次：取指令1次、执行指令0次、暂不考虑存结果

优点：指令执行阶段不访问主存，指令执行时间最短
缺点：A的位数限制了立即数的范围。
			如A的位数为n，且立即数采用补码时，可表示的数据范围为-2n-1~2n-1-1

#### 偏移寻址

偏移寻址——基址寻址、变址寻址、相对寻址

##### 基址寻址

基址寻址：以**程序的起始存放**地址作为起点
基址寻址：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A。

基址寄存器中是无符号数。指令中的形式地址是有符号数（补码表示）。
<font color='red'>**因此，补码先符号扩展，再转换为原码，然后二者相加/相减**</font>。

 <img src="E:\图片\图床\image-20240309234037974.png" alt="image-20240309234037974" style="zoom: 67%;" />     			 <img src="E:\图片\图床\image-20240309234204957.png" alt="image-20240309234204957" style="zoom: 60%;" />  R~0~位数看寄存器个数

优先：采用基址寻址无需修改指令中的地址码。
			方便程序“**<font color='red'>浮动</font>**”，方便实现多道程序并发运行。

基址寄存器是<font color='red'>**面向操作系统**</font>的，其<font color='red'>**内容由操作系统或管理程序**</font>确定。【汇编程序员可见】
在程序执行过程中，基址寄存器的内容不变（<font color='red'>作为基地址</font>），形式地址可变（<font color='red'>作为偏移量</font>)。

当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。

##### 变址寻址

变址寻址：**程序员自己决定**从哪里作为“起点”
变址寻址：有效地址EA等于指令字中的形式地址A与变址寄存器豹内容相加之和，即EA= (IX)+A，
					 其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。

 <img src="E:\图片\图床\image-20240310000055309.png" alt="image-20240310000055309" style="zoom:67%;" />

<font color='red'>变址寄存器是面向用户的</font> 
在程序执行过程中，变址寄存器的内容可由用户改变(<font color='red'>IX作为偏移量</font>)，形式地址A不变(<font color='red'>作为基地址</font>）

<img src="E:\图片\图床\image-20240310084934106.png" alt="image-20240310084934106" style="zoom:67%;" />

优点：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。



##### 基址&变址复合寻址

先基址后变址寻址：EA = (IX)+（(BR)+A）

##### 相对寻址

相对寻址：以**程序计数器PC所指地址**作为“起点”

相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址,
					 即EA=(PC)+"1"+A，其中<font color='red'>A是相对于PC所指地址的位移量</font>，可正可负，<font color='red'>补码表示</font>。【<font color='red'>**A为有符号数**</font>】
	PC(基地址)，A(偏移量)	【因为A，可正可负，因此可向前偏移、向后偏移】

<font color='red'>**注意**</font>：CPU取走指令以后，PC+1，再执行其他【因此相对寻址是相对于下一条指令的偏移，并不是当前】

优点：操作数的地址不是固定的，它随着PC值的变化而变化，并与指令地址之间总是相差一个固定值，因此便于程序浮动			【**一段代码在程序内部的浮动** 此浮动与基址寻址的浮动不同，基址寻址是**整段程序在内存中的浮动**】
			相对寻址广泛应用于转移指令。

##### 堆栈寻址

堆栈寻址：操作数存放在堆栈中，<font color='red'>隐含</font>使用堆栈指针(SP)作为操作数地址。

堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出(LIFO)原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)

![image-20240310100225662](E:\图片\图床\image-20240310100225662.png)

硬堆栈：使用专门的寄存器来实现堆栈【POP，PUSH无需访存】
软堆栈：从主存中划分出一片区域，用此区域作为堆栈【POP，PUSH需一次访存】

![image-20240310100705372](E:\图片\图床\image-20240310100705372.png)

## 程序的机器级代码表示

机器级代码：汇编语言、机器语言

### x86汇编语言

x86基本为小端存储

#### x86汇编语言基础

**如何指令内存的读写长度？**
	dword ptr——双字,32bit
	word ptr——单字,16bit
	bute ptr——字节,8bit

**x86架构常见寄存器** 【每个寄存器长度32bit，以E开头的寄存器32bit】【若将E去掉，则通用寄存器为低16bit】
									 【也可以将通用寄存器再次划分为两个8bit】
	<img src="E:\图片\图床\image-20240911145549650.png" alt="image-20240911145549650" style="zoom: 43%;" />  <img src="E:\图片\图床\image-20240911145843335.png" alt="image-20240911145843335" style="zoom:50%;" />	 <img src="E:\图片\图床\image-20240911145804764.png" alt="image-20240911145804764" style="zoom: 50%;" />

ecx寄存器——循环计数器	
eax寄存器——返回结果
堆栈寄存器——函数调用

mov 目的操作数d 源操作数s————将源操作数s复制到目的操作数d所指的位置

```
mov eax,ebx【将寄存器 ebx 的值复制到寄存器 eax】
mov eax,5【将立即数5复制到寄存器 eax】
mov eax,dword ptr[af996h]【内存地址 af996h 所指的32bit值复制到寄存器 eax】
mov byte ptr[af996h],5【将立即数5复制到内存地址 af996h 所指的一字节中】
mov eax,dword ptr[ebx]【将ebx所指内存地址的32bit复制到eax寄存器中】【寄存器间接寻址】
mov eax,[ebx]【若未指明主存读写长度，默认32bit】
mov eax,dword ptr[ebx+8]【将ebx+8所指主存地址的32bit复制到eax寄存器中】
```

在x86汇编语言中，**不允许两个操作数同时来自主存**。
**目的操作数d不可以是变量**。

#### 常用的x86汇编指令

**算术运算**				
d——目的操作数	s——源操作数			【运算结果放到d中】
	加						add d,s
	减						sub d,s	
	乘						mul d,s 		【无符号数d * s】
								mul d,s1,s2  【d=s1*s2】
								imul d,s		【有符号数d * s】
	除						div s			  【无符号数除法 edx:eax/s，商存入eax，余数存入edx】
								idiv s			 【有符号数除法 edx:eax/s，商存入eax，余数存入edx】
	取负数				neg d			
	自增++				inc d
	自减--				 dec d

除法：隐含寻址，将被除数提前放入edx和eax中【edx:eax：将被除数进行位扩展，32bit——>64bit。edx高位,eax低位】

**逻辑运算** 
	与					and d,s
	或					or	d,s
	非					not d
	异或				xor d,s
	左移				shl d,s	【将d进行逻辑左移s位。通常s为常量】
	右移				shr d,s

#### AT&T格式和Intel格式

AT&T格式常在Unix、Linux中使用
Intel格式常在Windows中使用

![image-20240911152603609](E:\图片\图床\image-20240911152603609.png)

### 选择语句的机器级表示

在x86处理器中PC通常被称为IP

#### 无条件转移指令J

无条件转移指令：jmp<地址>	【PC无条件转移至<地址>】

```
地址可以来自常数、寄存器、主存
jmp	128
jmp	eax	【eax中存储了常数】
jmp	[999]【主存地址999中存储了常数】
jmp NEXT【地址可以用标号锚定】
```

但是直接写死地址，不灵活——>用标号锚定位置
<img src="E:\图片\图床\image-20240911154331384.png" alt="image-20240911154331384" style="zoom: 55%;" />

#### 条件转移指令J

条件转移指令：jxxx

cmp	a,b【比较a和b两个数】【a、b两个数可能来自寄存器/主存/常量】

je <地址>			【jump when equal，若a==b则跳转】
jne<地址>		  【jump when not equal，若a!=b则跳转】
jg<地址>			【jump when greater than，若a>b则跳转】
jge <地址>	 	【jump when greater than or equal to，若a>=b则跳转】
j1 <地址>		   【jump when less than，若a<b则跳转】
jle <地址>	      【jump when less than or equal to，若a<=b则跳转】

### 循环语句的机器级表示

#### 用条件转移指令实现循环![image-20240911160353519](E:\图片\图床\image-20240911160353519.png) 

#### 用loop指令实现循环

loop Looptop【等价于①dec ecx ③cmp ecx,0 ③jne Looptop】

<img src="E:\图片\图床\image-20240911161016884.png" alt="image-20240911161016884" style="zoom: 60%;" />

理论上，能用loop指令实现的功能一定条件转移指令实现能用。
使用loop 指可能会使代码更清晰简洁。

loopx指令——如loopnz，loopz
	loopnz——当ecx!=0&&ZF==0时，继续循环
	loopz——当ecx!=0&&ZF=1时，继续循环	



### 函数调用的机器级表示

函数的栈帧(Stack Frame)：保存函数大括号内定义的局部变量、保存函数调用相关的信息

<img src="E:\图片\图床\image-20240911162713479.png" alt="image-20240911162713479" style="zoom: 50%;" /> 当前正在执行的函数栈帧，位于栈顶

#### 函数调用栈在内存中的位置 

<img src="E:\图片\图床\image-20240912151722502.png" alt="image-20240912151722502" style="zoom:60%;" />

<img src="E:\图片\图床\image-20240912151756685.png" alt="image-20240912151756685" style="zoom:60%;" />

#### call指令和ret指令

函数调用指令：call 函数名
函数返回指令：ret

 <img src="E:\图片\图床\image-20240911162903055.png" alt="image-20240911162903055" style="zoom: 50%;" />

call指令作用：
	①将**IP旧值**压栈保存（保存在函数的栈帧顶部）【效果相当于push P】
	②设置**IP新值**，无条件转移至被调用函数的第一条指令【效果相当于jmp add】

ret指令作用：
	从函数的栈帧顶部找到**IP旧值**，将其出栈并恢复IP寄存器

<font color='blue'>call和ret指令属于无条件转移指令</font> 

#### 如何访问栈帧

在一个CPU内部，只有一个EBP【栈帧底部】和一个ESP【栈帧顶部】
每个栈帧底部，用于保存上一层栈帧的基址

x86 系统中，默认以4字节为栈的操作单位.

<img src="E:\图片\图床\image-20240912152313481.png" alt="image-20240912152313481" style="zoom: 60%;" /> esp在下,ebp在上。上加下减

**访问栈帧数据：**
	**法一：**push、pop指令
		push、pop指令实现入栈、出栈操作。
			push A【先让esp减4，再将A压入(先减后入)】【A可以是立即数、寄存器、主存地址】
			pop B【栈顶元素出栈写入A，再让esp加4（先出后加）】	【B可以是寄存器、主存地址】

​	**法二：**mov指令
​		mov指令，结合esp、ebp指针访问栈帧数据
​		PS：可以使用add/sub指令，修改栈顶指针esp的值

#### 如何切换栈帧

**函数调用时，切换栈帧**
	push ebp		【保存上一层函数的栈帧基址(ebp旧值)】
	mov ebp,esp  【设置当前函数的栈帧基址（ebp新值）】

<u>上述两条指令在每个函数的开头都会执行</u>
也可以使用enter指令来代替上述两条指令【enter指令为零地址指令】

 <img src="E:\图片\图床\image-20240912153516442.png" alt="image-20240912153516442" style="zoom: 48%;" /> <img src="E:\图片\图床\image-20240912153534441.png" alt="image-20240912153534441" style="zoom: 48%;" /> <img src="E:\图片\图床\image-20240912153555885.png" alt="image-20240912153555885" style="zoom: 48%;" />

**函数返回时，切换栈帧** 
	mov esp,ebp【让esp指向当前栈帧的底部】
	pop ebp		【将esp所指元素出栈，写入寄存器ebp】

上述两条指令在每个函数的ret指令之前执行
也可以使用leave指令来代替上述两条指令【leave指令为零地址指令】

​    <img src="E:\图片\图床\image-20240912154437971.png" alt="image-20240912154437971" style="zoom:42%;" /><img src="E:\图片\图床\image-20240912154349376.png" alt="image-20240912154349376" style="zoom:45%;" /> <img src="E:\图片\图床\image-20240912154919387.png" alt="image-20240912154919387" style="zoom:67%;" />  

call指令是源函数中，enter、leave、ret指令是被调用的函数中的

<img src="E:\图片\图床\image-20240912155212474.png" alt="image-20240912155212474" style="zoom: 67%;" />    

#### 栈帧内容

gcc编译器将每个栈帧大小设置为 16B 的整数倍【当前函数的栈帧除外】因此栈帧内可能出现<font color='red'>空闲未使用</font>的区域。
通常将<font color='red'>局部变量</font>集中存储在<font color='red'>栈帧底部区域</font> 【ebp-4为第一个局部变量	ebp-8为第二个局部变量】
通常将<font color='red'>调用参数</font>集中存储在<font color='red'>栈帧顶部区域</font> 【esp+8为第一个调用参数    ebp+12为第二个调用参数】
调用其他函数前，如果有必要，可将某些<font color='red'>寄存器的值</font>入栈保存，防止中间结果被破坏【如:eax、edx、ecx】
<font color='red'>栈帧最底部</font>一定是<font color='red'>上一层栈帧基址</font>【ebp旧值】
<font color='red'>栈帧最顶部</font>一定是<font color='red'>返回地址</font>【当前函数的栈帧除外】 

C语言中，越靠前的局部变量离栈顶越近。越靠前的参数离栈顶越近。

只有栈帧最底部和栈帧最顶部的数据必然存在，其余的不一定存在

![image-20240912161842092](E:\图片\图床\image-20240912161842092.png)

PS：执行call指令之前，可以对寄存器的值进行压栈保存

访问当前函数的局部变量——[ebp-4]、[ebp-8]
访问上一层函数传递过来的参数——[ebp+8]、[ebp+12]

## CISC和RISC

CISC——复杂指令集的计算机系统

设计思路：一条指令完成一个复杂的基本功能
代表：**x86架构**，主要用于笔记本、台式机

80-20规律:典型程序中80%的语句仅仅使用处理机中20%的指令



RISC——精简指令集的计算机系统
代表：**MIPS**   

设计思路：一条指令完成一个基本“动作”。多条指令组合完成一个复杂的基本功能。
代表：ARM架构，主要用于手机、平板等

![image-20240310102723983](E:\图片\图床\image-20240310102723983.png)

<font color='red'>**CISC指令功能强大**</font> 
<font color='red'>**RISC特点：边界对齐也是**</font> 

**RISC的基本技术：**
	①RISC寄存器管理技术
	②流水线技术
	③延时转移技术

# 第五章——中央处理器

## CPU的功能和基本结构

### **CPU功能**

1.**指令控制**。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2.**操作控制**：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按照指令的要求进行动作。
3.**时间控制**。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4.**数据加工**。对数据进行算术和逻辑运算。
5.**中断处理**。对计算机运行过程中出现的异常情况和特殊请求进行处理。

### **运算器和控制器的功能**

运算器：接受从控制器发来的命令并执行对应的动作，对数据进行加工

控制器：协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令
			取指令：自动形成指令地址【<font color='red'>PC+"1"</font>】；自动发出取指令的命令【PC+1操作①PC自动加1②PC送入ALU+1】
			分析指令：操作码译码(分析本条指令要完成什么操作)；**<font color='red'>产生操作数的有效地址</font>**。
			执行指令：根据分析指令得到“操作命令”和“操作数地址”，形成操作信号控制序列。
								 控制运算器、存储器以及I/O设备完成相应的操作
			中断处理：管理总线及输入输出；处理异常情况(如掉电)和特殊请求(如打印机请求打印一行字符)

### **运算器的基本结构**

​	1.算术逻辑单元ALU，是一个组合逻辑电路，主要功能是进行算术/逻辑运算
​	2.通用寄存器组：如AX、BX、CX、SP等，用于存放操作数(包括源操作数、目的操作数及中间结果)和各种地址信息。
​									SP是堆栈指针，用于指示栈顶的地址。
​	3.暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏原有内容。
​				<font color='brown'>如:两个操作数分别来自主存和R~0~，最后结果存回R~0~，那么从主存中取来的操作数直接放入暂存器，就不会破坏运算前R~0~的内容。</font > 
​	4.累加寄存器ACC：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。
​	5.程序状态字寄存器PSW：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，
​												 	如溢出标志OP、符号标志SF、零标志ZF、进位标志CF等。
​													 PSW中的这些位参与并决定微操作的形成。
​	6.移位器：对运算结果进行移位运算。
​	7.计数器：控制乘除运算的操作步数。

运算器中含有：ALU、ACC、MQ、X、PSW、移位器、计数器、暂存寄存器、变址寄存器IX、基址寄存器BR

-----

 <img src="E:\图片\图床\image-20240311161920472.png" alt="image-20240311161920472" style="zoom:50%;" /> **专用数据通路方式**：根据指令执行过程中的数据和地址的流动方向安排连接线路。

 R~0~、R~1~等都有两跟线连接ALU的A、B端【因为R~0~可能是A的输入，也可能是B的输入】

专用数据通路方式问题：
	如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据
		方法1：使用**多路选择器**根据控制信号选择一路输出
		方法2：使用**三态门**可以控制每一路是否输出
				【R0out为1时，R~0~中的数据输出到A端；R0out为0时，R~0~中的数据无法输出到A端】

**优点：**性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。

-----

 <img src="E:\图片\图床\image-20240311173205888.png" alt="image-20240311173205888" style="zoom: 45%;" /> 
**CPU内部单总线方式**：将所有寄存器的输入端和输出端连接到一条公共的通路上。

R0in是输入信号，当R0in=1时，可以对R0进行输入

优点：结构简单，容易实现，但数据传输存在<font color='red'>较多冲突</font>的现象，<font color='red'>性能较低</font>。

-----

### **控制器的基本结构**

1.程序计数器PC：用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。
							因程序中指令（通常）是顺序执行的，所以PC有自增功能。
2.指令寄存器IR：用于保存当前正在执行的那条指令。
3.指令译码器ID：仅对**操作码字段**进行译码，向控制器提供特定的操作信号。
4.微操作信号发生器：根据IR的内容(指令)、PSW的内容(状态信息)和时序信号，产生控制计算机系统所需的各种控制信号										 结构有组合逻辑型和存储逻辑型两种。
5.时序系统：用于产生各种时序信号，它们都是由统一时钟(CLOCK) 分频得到。
6.存储器地址寄存器MAR：用于存放所要访问的主存单元的地址。

控制器中含有：PC、IR、CU、MAR、MDR、指令译码器、时序系统、微操作信号发生器

### **CPU基本结构**

<img src="E:\图片\图床\image-20240311175327490.png" alt="image-20240311175327490" style="zoom: 55%;" />

<font color='red'>用户可见</font>：PC、PSW、ACC、通用寄存器【可编程，应用程序员/汇编语言程序员可见】
<font color='red'>用户不可见</font>：MAR、MDR、IR、暂存寄存器、移位寄存器

<font color='red'>CPU专用寄存器</font>：PC、IR、MAR、MDR、PSW

## 指令执行过程

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间
指令周期常常用若干机器周期来表示，机器周期又叫CPU周期。【取值周期和执行周期都占一个CPU周期】
一个机器周期又包含若干时钟周期(也称为节拍、T周期或CPU时钟周期，**时钟周期是CPU操作的最基本单位**）

 <img src="E:\图片\图床\image-20240311205112409.png" alt="image-20240311205112409" style="zoom: 50%;" />			  <img src="E:\图片\图床\image-20240311205230974.png" alt="image-20240311205230974" style="zoom:67%;" />

每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。

中断周期：当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在<font color='red'>**每条指令执行结束前**</font>，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段

​	<img src="E:\图片\图床\image-20240311205709614.png" alt="image-20240311205709614" style="zoom: 50%;" />

一个完整的指令周期包括取指周期、间址周期、执行周期和中断周搠。
		取指和执行周期是每条指令都有的。【取值周期——取指令PC+1、对指令译码】
		间址周期只有间接寻址(存储器间接寻址)的指令才有。
		中断周期只有在条件满足时才有。

**访存目的**				<img src="E:\图片\图床\image-20240829165919487.png" alt="image-20240829165919487" style="zoom:50%;" />

 				![image-20240311210237058](E:\图片\图床\image-20240311210237058.png)     

<font color='orange'>**使用触发器来判断当前指令在哪步操作**</font> 

### **指令周期的数据流**

#### **取值周期** 

![image-20240311211613619](E:\图片\图床\image-20240311211613619.png)

#### 间址周期

![image-20240311212356537](E:\图片\图床\image-20240311212356537.png)

#### 执行周期

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。
不同指令的执行周期操作不同，因此没有统一的数据流向。

#### 中断周期

中断：暂停当前任务去完成其他任务

为了能够恢复当前任务，需要**保存断点(PC)**。
	一般使用<font color='red'>**堆栈来保存断点**</font>，这里用SP表示栈顶地址，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据。
	【栈顶指针一般指向低地址部分。栈内元素从高地址到低地址依次排列】

![image-20240311213606367](E:\图片\图床\image-20240311213606367.png)

### **指令执行方案**

**方案1：单指令周期** 
		对所有指令都选用相同的执行时间来完成【每条指令在一个时钟周期内完成——>CPI=1】

​		指令之间串行执行；指令周期取决于执行时间最长的指令的执行时间。

​		缺点：对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。
​		优点：电路设计简单

**方案2：多指令周期** 
		对不同类型的指令选用不同的执行步骤来完成。【CPI>1】

​		指令之间串行执行；可选用不同个数的时钟周期来完成不同指令的执行过程。

​		缺点：需要更复杂的硬件设计。

**方案3：流水线方案** 
		在每一个时钟周期启动一条指令尽量让多条指令同时运行，但各自处在不同的执行步骤中。

​		指令之间并行执行。

------

**<font color='blue'>①取指操作由控制器自动进行，不需要在操作码控制下完成</font>**。
**<font color='blue'>②第一个机器周期——从主存中取指令字</font>**。
<font color='blue'>**③机器周期由存取周期决定**</font>。
**<font color='blue'>④指令字长=存储字长，则取指周期=机器周期</font>**。
**<font color='blue'>⑤指令字长和机器字长的长度无关系</font>**。
**<font color='blue'>⑥空操作指令也会导致寄存器值改变：PC+"1"</font>**。
<font color='blue'>**⑦单周期处理器(CPI=1)不能采用单总线方式**</font>。
	<font color='blue'>**因为单总线将所有寄存器都连接到一条公共总线上，一个时钟只能一次操作，无法完成一条指令的所有操作**</font>。

## 数据通路的功能和基本结构

数据通路：数据在功能部件之间传送的路径。
					数据通路由控制部件控制，因此数据通路不包含控制部件。
组成数据通路的元件：
				组合逻辑元件【组合电路不含存储信号的记忆单元】【加法器、ALU、译码器、多路选择器、三态门】
				时序逻辑元件【时序电路必含存储信号的记忆单元】【通用寄存器组、PC、PSW】

由控制部件产生的控制信号建立数据通路

总线BUS

**内部总线**是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线;
**系统总线**是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间互相连接的总线。

### **CPU内部单总线结构** 

#### 寄存器之间的数据传送

比如把PC内容送至MAR，实现传送操作的流程及控制信号为：
			(PC)—>Bus		  PCount有效，PC内容送至总线
			Bus—>MAR	     MARin有效，总线内容送至MAR

#### 主存与CPU之间的数据传送

比如CPU从主存读取指令，实现传送操作的流程及控制信号为： 	
			(PC)—>Bus—>MAR	PCount和MARin有效，现行指令地址—>MAR
			1—>R							 CU发读命令（通过控制总线发出）
			M(MAR)—>MDR		 MDRinE有效【主存根据MAR中的地址读出相应的数据，放到MDR中】	
												  【MDRinE是从**<font color='red'>外部</font>**到MDR的输入信号；若是从CPU内部总线则是MDRin】
			MDR—>Bus—>IR		MDRout和IRin有效，现行指令—>IR

#### 执行算术或逻辑运算

比如一条加法指令，微操作序列及控制信号为：
	Ad(IR)—>Bus—>MAR				  MDRout和MARin有效	/	AdIRout和MARin有效
	1—>R											   CU发读命令（通过控制总线发出）
	M(MAR)—>数据线—>MDR		 MDRinE有效【主存根据MAR中的地址读出相应的数据，放到MDR中】	
	MDR—>Bus—>Y						    MDRout和Yin有效，操作数→Y【Y为暂存寄存器】	【若是多总线，则可以不使用Y】
	(ACC)+(Y)—>Z							   ACCout和ALUin有效，CU向ALU发送加命令
	Z—>ACC										  Zout和ACCin有效，结果→ACC

 <img src="E:\图片\图床\image-20240312090756564.png" alt="image-20240312090756564" style="zoom:67%;" />										

------

![image-20240312091702521](E:\图片\图床\image-20240312091702521.png)

 <img src="E:\图片\图床\image-20240312092456229.png" alt="image-20240312092456229" style="zoom:57%;" />       <img src="E:\图片\图床\image-20240312092755080.png" alt="image-20240312092755080" style="zoom:58%;" />

 <img src="E:\图片\图床\image-20241124075737281.png" alt="image-20241124075737281" style="zoom: 67%;" /><img src="E:\图片\图床\image-20240312092456229.png" alt="image-20240312092456229" style="zoom:45%;" /><img src="E:\图片\图床\image-20240312092755080.png" alt="image-20240312092755080" style="zoom: 50%;" />





寄存器间接寻址

### **专用数据通路 ** 

专用数据通路使用 多路选择器或三态门

**取值周期 **

![image-20240312094358547](E:\图片\图床\image-20240312094358547.png)

----

![image-20240312111614440](E:\图片\图床\image-20240312111614440.png)

<img src="E:\图片\图床\image-20240312111657369.png" alt="image-20240312111657369" style="zoom:50%;" />  		<img src="E:\图片\图床\image-20240312111722163.png" alt="image-20240312111722163" style="zoom:50%;" />		   

 <img src="E:\图片\图床\image-20240312112523813.png" alt="image-20240312112523813" style="zoom: 80%;" />

**为什么需要设置暂存寄存器？**
	在单总线结构中，每一时刻总线上只有一个数据有效，而ALU有两个输入端和一个输出端。因此，当ALU运算时，需要先用暂存器Y缓存一个输入端的数据，再通过总线传送另一个输入端的数据。
	与此同时，ALU的输出端产生运算结果，但是由于总线正被占用，因此需要暂存器，以缓存ALU的输出端数据。

-------

<font color='blue'>**①单总线结构，控制部件与总线连接或断开——三态门**</font>。
<font color='blue'>**②总线上信号流动原则：同一时刻只有一个器件发出信息，可有多个器件接受信息**</font>。
<font color='blue'>**③一条指令执行过程中，单周期CPU中的每个控制信号一直不变，多周期CPU中的控制信号可能会发生改变**</font>。
<font color='blue'>**④单周期CPU时钟频率低**</font>。
<font color='blue'>**⑤ADD R1 (R2)**</font><font color='red'>**最后将结果存入R1**</font>。

## 控制器的功能和工作原理

一个时钟周期【节拍】内可包含多个微操作。
一个节拍内可以<font color='red'>并行</font>完成多个“相容的”微操作。		微操作和微命令一一对应。 一个微命令对应一根输出线。
同一微操作可能在不同指令的不同阶段被使用。

不同指令的执行周期所需节拍数各不相同。为了简化设计，选择<font color='red'>定长的机器周期</font>，以可能出现的最大节拍数为准
【<font color='red'>通常以访存所需节拍数作为参考</font>】

若实际所需节拍数较少，可将微操作安排在机器周期末尾几个节拍上进行

 <img src="E:\图片\图床\image-20240313081210181.png" alt="image-20240313081210181" style="zoom:50%;" />

### **硬布线控制器的设计**  

根据<font color='blue'>**指令操作码**</font >、**<font color='purple'>目前的机器周期</font>**、<font color='brown'>**节拍信号**</font >、**<font color='green'>机器状态条件</font>**，即可确定现在这个节拍下**<font color='red'>应该发出哪些“微命令”</font>**。

![image-20240313082941352](E:\图片\图床\image-20240313082941352.png)

**硬布线控制器的特点:**
	指令越多，设计和实现就越复杂，因此一般用于**RISC**(精简指令集系统)
	如果扩充一条新的指令，则控制器的设计就需要大改，因此**扩充指令较困难**。
	由于使用纯硬件实现控制，因此**执行速度很快**。
	微操作<font color='red'>**控制信号**</font>由组合逻辑电路根据指令码、状态、时序，**<font color='red'>即时产生</font>**。

#### **设计步骤** 

1.分析每个阶段的微操作序列(取指、间址、执行、中断 四个阶段)
							【确定哪些指令在什么阶段、在什么条件下会使用到的微操作】
2.选择CPU的控制方式【定长机器周期/不定长机器周期，一个机器周期内安排几个节拍】
3.安排微操作时序【如何用规定的节拍数完成整个机器周期内的所谓微操作】
4.电路设计【确定每个微操作命令的逻辑表达式，并用电路实现】

![image-20240313092039042](E:\图片\图床\image-20240313092039042.png)

#### **安排微操作时序的原则**  

原则1：微操作的**先后顺序**不得随意**更改** 
原则2：**被控对象不同**的微操作
			   尽量安排在**一个节拍**内完成
原则3：占用**时间较短**的微操作
			   尽量安排在**一个节拍**内完成
			   并**允许有先后顺序** 

##### 取指周期 

 <img src="E:\图片\图床\image-20240313092830191.png" alt="image-20240313092830191" style="zoom:67%;" />

M(MAR)→MDR从主存取数据，用时较长，因此必须一个时钟周期才能保证微操作的完成
MDR→IR是**CPU内部寄存器的数据传送，速度很快**，因此在一个时钟周期内可以紧接着完成OP( IR)→ID。也就是可以一次同时发出两个微命令。

##### 间址周期

 <img src="E:\图片\图床\image-20240313093027175.png" alt="image-20240313093027175" style="zoom:67%;" />

##### 执行周期 

 <img src="E:\图片\图床\image-20240313093309526.png" alt="image-20240313093309526" style="zoom:67%;" /> 



### **微程序控制器**

#### 微程序控制器的基本原理

程序:由指令序列组成

微程序：由微指令序列组成，**每一种指令对应一个微程序。** 
**指令**是对程序执行步骤的描述
**微指令**是对指令执行步骤的描述

**微命令**与**微操作**一一对应。一个微命令对应一根输出线。
有的微命令可以并行执行，**微指令**中可能包含多个**微命令** 

**微程序**和**指令**一一对应 
一种机器指令对应一个微程序，一个微程序由微指令序列组成
机器指令是对微指令的封装

![image-20240313124421500](E:\图片\图床\image-20240313124421500.png)

采用“存储程序”的思想，CPU出厂前将所有指令的“微程序”存入“控制存储器”中

 <img src="E:\图片\图床\image-20240313105110198.png" alt="image-20240313105110198" style="zoom:50%;" /> 

#### 微程序控制器的基本结构

控制存储器CM：用于存放各指令对应的微程序，控制存储器可用只读存储器**<font color='red'>ROM</font>**构成。
							   按地址寻访。通常在CPU出厂时就把所有微程序写入。

微地址寄存器CMAR：uPC，接受微地址形成部件送来的微地址，为在CM中读取微指令作准备。

CMDR：uIR，用于存放从CM中取出的微指令，它的**<font color='red'>位数同微指令字长相同</font>**。

微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行。

<img src="E:\图片\图床\image-20240313145908216.png" alt="image-20240313145908216" style="zoom:67%;" />

#### 微程序控制器的工作原理  

 <img src="E:\图片\图床\image-20240313150029570.png" alt="image-20240313150029570" style="zoom: 50%;" /> <img src="E:\图片\图床\image-20240830222723099.png" alt="image-20240830222723099" style="zoom:68%;" />

PS：物理上，取指周期、执行周期看起来像是两个微程序
		但逻辑上应该把它们看作一个整体。因此，“一条指令对应一个微程序”的说法是正确的

### **微指令的设计** 

相容性微命令：可以并行完成的微命令
互斥性微命令：不允许并行完成的微命令

**水平型微指令**：一条微指令能定义<font color='red'>**多个**</font>可**<font color='red'>并行</font>**的微命令。

 <img src="E:\图片\图床\image-20240313151548268.png" alt="image-20240313151548268" style="zoom:50%;" />	操作控制字段会很长

优点：微指令少，执行速度快
缺点：微指令长，编写微程序较麻烦

**垂直型微指令**：一条微指令只能对应<font color='red'>**一个**</font>微命令，由微操作码字段规定具体功能

 <img src="E:\图片\图床\image-20240313151712910.png" alt="image-20240313151712910" style="zoom:50%;" /> 微操作码字段会较短

优点：微指令短，简单、规整，便于编写微程序
缺点：微程序长，微指令多，执行速度慢，<font color='red'>工作效率低</font> 

**混合型微指令**

在垂直型的基础上增加一些不太复杂的并行操作。
微指令较短，仍便于编写;微程序也不长，执行速度加快。

#### 水平微指令的编码方式

微指令的编码方式又称为微指令的控制方式
它是指如何对微指令的控制字段进行编码，以形成控制信号。
编码的目标是在保证速度的情况下，尽量缩短微指令字长。

**1.直接编码(直接控制)方式**
		在微指令的操作控制字段中，每一位代表一个微操作命令
		某位为“1”表示该控制信号有效

​		<img src="E:\图片\图床\image-20240313152342965.png" alt="image-20240313152342965" style="zoom:43%;" />

​		优点：简单、直观，执行速度快，操作并行性好。无需译码，效率最高。
​		缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大。

**2.字段直接编码方式** 
		将微指令的控制字段分成若干“段”，每段经译码后发出控制信号

​		微命令字段分段的原则：
​		①**互斥性**微命令分在同一段内，**相容性**微命令分在不同段内
​		②**每个小段**中包含的**信息位不能太多**，否则将增加译码线路的复杂性和译码时间
​		③一般**每个小段还要留出一个状态**，表示本字段不发出任何微命令。
​			因此，当某字段的长度为3位时，最多只能表示7个互斥性的微命令，**通常用000表示不操作**。

 		<img src="E:\图片\图床\image-20240313162337419.png" alt="image-20240313162337419" style="zoom:50%;" />  

优点：可以缩短微指令字长。
缺点：要通过译码电路后再发出微命令，因此比直接编码分式慢。

----

<img src="E:\图片\图床\image-20240313163424089.png" alt="image-20240313163424089" style="zoom: 50%;" />

-----

**3.字段间接编码方式/隐式编码**
		一个字段的某些微命令需由另一个字段中的某些微命令来解释，不是靠字段直接译码发出的微命令

 		<img src="E:\图片\图床\image-20240313163817449.png" alt="image-20240313163817449" style="zoom:50%;" />		

优点：可进一步缩短微指令字长。
缺点：削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。

#### 微指令的地址形成方式

**1.微指令的<font color='red'>下地址字段</font>指出**
		微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称为**<font color='red'>断定方式</font>** 

**2.根据机器指令的<font color='red'>操作码</font>形成** 
		当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。

**3.增量<font color='red'>计数器法</font>**	 **(CMAR)+1—>CMAR** 

**4.分支转移**
		转移方式 ：指明判别条件
		转移地址：指明转移成功后的去向

 	<img src="E:\图片\图床\image-20240313164618518.png" alt="image-20240313164618518" style="zoom:67%;" />

**5.通过测试网络**  【了解即可】
		<img src="E:\图片\图床\image-20240313164709570.png" alt="image-20240313164709570" style="zoom:50%;" />

**6.由硬件产生微程序入口地址** 
		**第一条微指令地址**		由专门**硬件**产生（用专门的硬件记录取值周期微程序首地址）
		中断周期 由硬件产生中断周期微程序首地址（用专门的硬件记录）

----

 			<img src="E:\图片\图床\image-20240313165051724.png" alt="image-20240313165051724" style="zoom:50%;" />		下地址字段多少位 —— 多个微指令

---

#### **微程序控制单元的设计**

设计步骤：
	1.分析每个阶段的微操作序列
	2.写出对应机器指令的微操作命令及节拍安排
		写出每个周期所需要的微操作(参照硬布线)
		补充微程序控制器特有的微操作
			a:取值周期
			   Ad(CMDR)—>CMAR【每条微指令结束后都需要进行】
			   OP(IR)—>微地址形成部件—>CMAR【取值周期最后一条微指令完成后，根据操作码确定执行周期微程序首地址】			b:执行周期
				Ad(CMDR)—>CMAR【每条微指令结束后都需要进行】
	3.确定微指令格式
		根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。
		根据CM中存储的微指令总数，确定微指令的顺序控制字段的位数。
		最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。
	4.编写微指令码点
		根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。

<img src="E:\图片\图床\image-20240313174458619.png" alt="image-20240313174458619" style="zoom: 50%;" />

取指周期的第一条微指令地址由硬件自动给出
在执行完微指令a之后，还需要 Ad(CMDR)—>CMAR	【此操作也需要消耗一个节拍】
																								  【用当前微指令的下地址表示找到下一条微指令】
转入下一个机器周期：OP(IR)→微地址形成部件→CMAR

#### **硬布线与微程序的比较**

![image-20240313175411106](E:\图片\图床\image-20240313175411106.png)

## **异常和中断机制**

CPU内部——异常、内中断
CPU外部——中断、外中断

### **异常的分类**

1.故障
	缺页/缺段【**可返回继续执行**】
	除0、非法操作码【**不可返回继续执行**】

2.自陷/陷阱/陷入
	当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行

​	故障异常和自陷异常属于程序性异常（软件中断）

3.终止
	若在执行指令的过程中发送了使计算机无法继续执行的硬件故障【控制器出错、存储器校验错误】则程序无法继续执行

​	终止异常和外中断属于硬件中断

### **中断的分类**

来自CPU外部、与CPU执行指令无关的时间引起的中断
包括I/O设备发出的I/O中断，或发生某种特殊事件（如Esc、定时器计数时间到）

1.可屏蔽中断
		通过可屏蔽中断请求线**INTR**向CPU发出的中断请求

2.不可屏蔽中断
		通过可屏蔽中断请求线**NMI**向CPU发出的中断请求

![image-20240316121303465](E:\图片\图床\image-20240316121303465.png)



## 指令流水线

时间并行——流水线技术
空间并行——超标量处理机

流水线对于指令集的要求：
	①指令长度尽量一致，有利于简化取指和指令译码操作
	②指令格式尽量规整，尽量保证源寄存器位置相同
	③**采用LOAD/STRORE访存，其他指令都不能访存** 
	④**数据和指令在存储器中“按边界对齐”存放**。有利于减少访存次数。

设取指、分析、执行3个阶段的时间都相等，用t表示，按以下几种执行方式分析n条指令的执行时间:

**1.顺序执行方式**
<img src="E:\图片\图床\image-20240313230939154.png" alt="image-20240313230939154" style="zoom: 50%;" />

传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。
**总耗时T = n * 3t = 3nt** 

优点：控制简单，硬件代价小
缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低

**2.一次重叠执行方式** 
<img src="E:\图片\图床\image-20240313231508822.png" alt="image-20240313231508822" style="zoom: 50%;" />

​	**总耗时T = 3t+(n-1)×2t =(1+2n)t**  

优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高。
缺点：需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了。

**3.两次重叠执行方式** 
<img src="E:\图片\图床\image-20240313231817850.png" alt="image-20240313231817850" style="zoom:50%;" />

优点：与顺序执行方式相比，指令的执行时间缩短近2/3。
			这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。

​	**总耗时T= 3t +(n-1)t = (2+n)t** 

### **指令流水线计算方法**

n个指令，m个阶段
		第一个阶段：nt
		剩余时间：(m-1)t
	总时间：(n+m-1)*t

### **流水线的表示方法 ** 

**1.指令执行过程图** 
	<img src="E:\图片\图床\image-20240313232318572.png" alt="image-20240313232318572" style="zoom:80%;" />

**2.时空图** 

![image-20240313232354907](E:\图片\图床\image-20240313232354907.png)



### **流水线的性能指标**

**1.吞吐率** 
	吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。
		设任务数为n；处理完成n个任务所用的时间为T~k~ 
		则计算流水线吞吐率（TP）的最基本的公式为<img src="E:\图片\图床\image-20240313233227669.png" alt="image-20240313233227669" style="zoom: 50%;" /> 
		<img src="E:\图片\图床\image-20240313233500431.png" alt="image-20240313233500431" style="zoom:50%;" />



**2.加速比** 
	加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。
			设T~0~表示不使用流水线时的执行时间，即顺序执行所用的时间；
			T~k~表示使用流水线时的执行时间
	则计算流水线加速比(S)的基本公式为<img src="E:\图片\图床\image-20240313233718449.png" alt="image-20240313233718449" style="zoom:50%;" /> 

​	<img src="E:\图片\图床\image-20240313233759464.png" alt="image-20240313233759464" style="zoom:50%;" /> 当连续输入的任务n→∞时，最大加速比为S~max~=k



**3.效率 ** 
	流水线的设备利用率称为流水线的效率

​	在时空图上，流水线的效率定义为<font color='red'>完成n个任务占用的时空区有效面积</font>
​	<font color='blue'>与n个任务所用的时间与k个流水段所围成的时空区总面积之比</font>。

<img src="E:\图片\图床\image-20240313234203594.png" alt="image-20240313234203594" style="zoom:50%;" />

![image-20240313234336384](E:\图片\图床\image-20240313234336384.png)

当连续输入的任务n→∞时,最高效率E~max~=1

### **流水线的影响因素** 

**结构相关（资源冲突） ** 
	由于多条指令在同一时刻争用同一资源而形成的冲突。

 <img src="E:\图片\图床\image-20240314092642269.png" alt="image-20240314092642269" style="zoom:50%;" />

​	解决方法：①后一相关指令暂停一周期
​					 	②资源重复配置：数据存储器+指令存储器【通常采用数据Cache和指令Cache分离】

**数据相关（数据冲突）** 【写后读冲突】
	在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。

<img src="E:\图片\图床\image-20240314092610420.png" alt="image-20240314092610420" style="zoom:50%;" />      <img src="E:\图片\图床\image-20240902172305119.png" alt="image-20240902172305119" style="zoom:43%;" />

​	解决方法：
​		①把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。
​			可分为**硬件阻塞(stall)**和**软件插入“NOP”**两种方法。 
​		②数据旁路技术【不从寄存器中取，直接从上一指令ALU的输出端，接到此指令的输入端】【从EX末直接到EX头】
​		③编译优化：通过编译器调整指令顺序来解决数据相关

<font color='red'>**是否有数据相关**</font>——>看写寄存器A的后续三条指令，是否在读中有寄存器A。
<font color='red'>**当采用转发技术**</font>——>从上一条指令的EX末段到下一条指令的EX头部。
但是不能解决由Load指令写寄存器引起的Load-use数据冒险【Load指令把数据读到寄存器，下一条指令就使用寄存器】
因此，若为Load指令要在ID段之后阻塞一个时钟，EX段要在上一条指令的M段之后

**控制相关（控制冲突） ** 
	当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关

​	解决方法：
​		①转移指令的分支预测。简单预测（永远猜ture或flase）、动态预测（根据历史情况动态调整）
​		②预取转移成功和不成功两个控制流方向上的目标指令
​		③加快和提前形成条件码
​		④提供转移方向的猜准率
​		⑤**将转移类指令后一条指令的IF段硬件阻塞3个时钟**。【<font color='red'>**将IF放在M(修改PC值)之后**</font>】	

①<font color='red'>**旁路技术可以解决大部分的数据冒险，但是不能解决由Load指令写寄存器引起的Load-use数据冒险**</font>。

### **流水线的分类** 

**1.部件功能级、处理机级和处理机间级流水线** 
	根据**流水线使用的级别**的不同，流水线可分为**部件功能级流水线**、**处理机级流水线**和**处理机间流水线**。

​	部件功能级流水就是将**复杂的算术逻辑运算**组成流水线工作方式。
​		例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。
​	处理机级流水是把**一条指令解释过程分成多个子过程**，如前面提到的取指译码、执行、访存及写回5个子过程。
​	处理机间流水是一种宏流水，其中**每一个处理机完成某一专门任务**，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。

**2.单功能流水线和多功能流水线** 
	按流水线可以完成的功能，流水线可分为单功能流水线和多功能流水线。

​	单功能流水线指只能实现一种固定的专门功能的流水线。
​	多功能流水线指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。

**3.动态流水线和静态流水线** 
	按同一时间内各段之间的连接方式,流水线可分为静态流水线和动态流水线。

​	静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作
​	动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。

**4.线性流水线和非线性流水线** 
	按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。

​	线性流水线中，从输人到输出，每个功能段只允许经过一次，**不存在反馈回路**。
​	非线性流水线**存在反馈回路**，从输入到输出过程中，某些功能段将数次通过流水线,这种流水线适合进行线性递归的运算

### **流水线的多发技术** 

**1.超标量技术** 
	<img src="E:\图片\图床\image-20240314092108770.png" alt="image-20240314092108770" style="zoom:50%;" />

每个时钟周期内可**并发多条独立指令** 
要配置多个功能部件
**不能调整指令的执行顺序** 
通过编译优化技术，把可并行执行的指令搭配起来

**2.超流水技术** 
	<img src="E:\图片\图床\image-20240314092149827.png" alt="image-20240314092149827" style="zoom:50%;" /> 

​	在一个时钟周期内再分段(3段)
​	在一个时钟周期内一个功能部件使用多次(3次)
​	**不能调整指令的执行顺序**
​	靠编译程序解决优化问题

**3.超长指令字** 
	<img src="E:\图片\图床\image-20240314092345987.png" alt="image-20240314092345987" style="zoom:50%;" />

由**编译程序挖掘**出指令间**潜在**的**并行性**，
将**多条**能**并行操作**的指令组合成**一条** 
具有**多个操作码字段**的**超长指令字**（可达几百位)
**采用多个处理部件** 	

### **五段式指令流水线** 

流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器	【使各阶段的耗时相同】
			其作用是保存本流水段的执行结果，提供给下一流水段使用。

Cache模块分为数据Cache和指令Cache【IF中存储指令、M中存储数据】，因此可以并行工作

IF：取值，从指令寄存器或Cache中取指令
ID：指令译码，从通用寄存器中取数，把数放到锁存器中【数也有可能是立即数Imm】【<font color='red'>**读寄存器**</font>】
EX：执行阶段，ALU处理上一阶段的两个数值
M：访存阶段，对存储器进行读/写操作
WB：写回阶段，将指令执行结果写回寄存器堆【<font color='red'>**写寄存器**</font>】
<img src="E:\图片\图床\image-20240314092749710.png" alt="image-20240314092749710" style="zoom: 67%;" />

为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。【流水段寄存器，锁存数据，位数不一定相等】

理想情况下，每个机器周期(功能段）只消耗一个时钟周期。

#### 运算类指令的执行过程
<img src="E:\图片\图床\image-20240902173525717.png" alt="image-20240902173525717" style="zoom:69%;" /><img src="E:\图片\图床\image-20240314102317935.png" alt="image-20240314102317935" style="zoom: 67%;" />          

**即使M是空段，也需要消耗时间**  

#### LOAD指令

 <img src="E:\图片\图床\image-20240314102959734.png" alt="image-20240314102959734" style="zoom: 80%;" />			 <img src="E:\图片\图床\image-20240314103010509.png" alt="image-20240314103010509" style="zoom:80%;" />

**通常，RISC处理器只有“取数LOAD”和“存数STORE指令才能访问主存**   

#### STORE指令

 <img src="E:\图片\图床\image-20240314103225241.png" alt="image-20240314103225241" style="zoom:80%;" /> <img src="E:\图片\图床\image-20240314103236452.png" alt="image-20240314103236452" style="zoom:80%;" />

#### 条件转移指令  

<img src="E:\图片\图床\image-20240314103555461.png" alt="image-20240314103555461" style="zoom:67%;" />

 <img src="E:\图片\图床\image-20240314103629505.png" alt="image-20240314103629505" style="zoom:67%;" />     ![image-20240314103650757](E:\图片\图床\image-20240314103650757.png)

#### 无条件转移指令 

 <img src="E:\图片\图床\image-20240314103842350.png" alt="image-20240314103842350" style="zoom: 67%;" /> <img src="E:\图片\图床\image-20240314103858615.png" alt="image-20240314103858615" style="zoom:67%;" />

"WrPC段”耗时比EX段更短，可安排在EX段时间内完成。
WrPC段越早完成，就越能避免控制冲突、当然，也有的地方会在WB段时间内才修改PC的值

![image-20241019095516261](E:\图片\图床\image-20241019095516261.png)



![image-20240314104730056](E:\图片\图床\image-20240314104730056.png)

<font color='red'>**只有上一条指令进入ID段后，下一条指令才能开始IF段，否则会覆盖IF段锁存器的内容**</font>    

## 多处理机

基于指令流和数据流的数量，对计算机体系结构分为SISD、SIMD、MISD、MIMD四类。
	常规的单处理器属于SISD，常规的多处理器属于MIMD

**1.单指令流单数据流结构SISD** 
	特性：①各指令序列<font color='blue'>只能并发、不能并行</font>，每条指令处理一两个数据
				 ②<font color='red'>不是数据级并行技术</font> 
	硬件组成：①一个处理器+一个存储器
						 ②若采用指令流水线，需要设置多个功能部件，采用多模块交叉存储

**2.单指令流多数据流结构SIMD** 
	特性：①各指令序列<font color='blue'>只能并发、不能并行</font>，但每条指令可同时处理多个具有相同特征的数据
				②是<font color='red'>数据级并行技术</font>
	硬件组成：①一个指令控制部件CU+多个处理单元/执行单元(如ALU)+多个局部存储器+一个主存储器
						②每个执行单元有各自的寄存器组、局部寄存器、地址寄存器
						③不同执行单元执行同一条指令，处理不同的数据

​	适合循环，不适合

**3.多指令流单数据流结构MISD** 
	<font color='blue'>多条指令并行执行</font>，处理同一个数据。现实中不存在。

**4.多指令流多数据流结构MIMD**
	特性：①各<font color='blue'>指令序列并行执行</font>，分别处理多个不同的数据
				②是一种 <font color='red'>线程级并行</font>、甚至是线程级以上并行技术
	进一步分类：
		**多处理器系统/共享内存多处理器**
				特性 ：各处理器之间，可以通过LOAD/STORE指令，访问同一个主存储器，可通过主存相互传送数据
				硬件组成：一台计算机内，包含多个处理器+一个主存储器【<font color='red'>多个处理器共享单一的物理地址空间</font>】
		**多计算机系统**
				特性：各计算机之间，不能通过LOAD/STORE指令直接访问对方的存储器，只能通过“消息传递”相互传送数据
				硬件组成：由多台计算机组成，因此拥有多个处理器+多个主存储器
									【<font color='red'>每台计算机拥有各自的私有存储器，物理地址空间相互独立</font>】

**5.向量处理器** 
	特性：①一条指令的处理对象是“向量”
				②擅长对向量型数据并行计算、浮点数运算，常被用于超级计算机中，处理科学研究中巨大运算量
	硬件组成：①多个处理单元，多组“向量寄存器”
						②主存储器应采用“<font color='red'>多个端口同时读取</font>”的交叉多模块存储器
						③主存储器大小限定了机器的解题规模，因此要有大容量的、集中式的主存储器



# 第六章——总线	

## 总线概述

每根总线可能由很多根信号线组成

总线是一组能为多个部件<font color='red'>**分时共享**</font>的**公共**信息传送线路
		分时：同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。
		共享：总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。
	<u>同一时刻只能有一个部件发生数据，但是可以有多个部件接受数据</u> 

**数据通路**表示的是数据流经的路径【逻辑】
**数据总线**是承载的媒介【物理】

为什么使用总线？
	早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备。
	为了更好地解决I/O设备和主机之间连接的灵活性问题，**计算机的结构从分散连接发展为总线连接**。
	便于增减外设，减少信息传输线的条数，提高信息传输量，降低信息的传输速度，降低并行性

总线设备：总线上所连接的设备，按其对总线有无控制权可以分为主设备和从设备
	主设备——获得总线控制权的设备
	从设备——被主设备访问的设备，只能响应从主设备发来的各种总线命令

### **总线特性**

1.机械特性：尺寸、形状、管脚数、排列顺序
2.电气特性：传输方向和有效的电平范围
3.功能特性：每根传输线的功能(地址、数据、控制)
4.时间特性：信号的时序关系

### **总线分类** 

**1.按数据传输格式分类** 

**串行总线**：每次传送1bit数据
	优点：只需要一个传输线，成本低，广泛应用于长距离传输，抗干扰强。应用于计算机内部时，可以节省布线空间。
	缺点：在数据发送和接收的时候要进行拆卸和装配，要考虑串行—并行转换的问题。

**并行总线**：每次可以传送多个bit的数据	
	优点：总线的逻辑时序比较简单，电路实现起来比较容易。
	缺点：信号线数量多，占用更多的布线空间;远距离传输成本高昂；
		 	由于工作频率较高时,并行的信号线之间会产生严重干扰,对每条线等长的要求也越高,所以无法持续提升工作频率。

①<font color='blue'>**当工作频率相等时，串行总线传输速度<并行总线传输速度**</font>。
②<font color='blue'>**并行总线传输速度无法持续提高，而串行总线可以不断提高工作频率来提高传输速度，最终超过并行总线**</font>。

**2.按总线功能分类(连接的部件)**

**片内总线**：
		片内总线是芯片内部的总线。
		它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。

**系统总线**：
		系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。
		按系统总线传输信息内容的不同，又可分为3类：数据总线、地址总线和控制总线。
			数据总线DB——传输各功能部件之间的数据信息,包括<font color='red'>指令和操作数</font>；<font color='blue'>位数(根数)与机器字长、存储字长有关</font>；<font color='red'>**双向**</font> 
			地址总线AB——传输地址信息,包括主存单元或I/O端口的地址;<font color='blue'>位数(根数)与主存地址空间大小及设备数量有关</font>;<font color='red'>**单向**</font> 
			控制总线CB——一根控制线传输一个信号;
										有出：CPU送出的控制命令；
										有入：主存(或外设)返回CPU的反馈信号。
										<font color='red'>**单个来说是单向的。整体来说是双向的**</font> 

 <img src="E:\图片\图床\image-20240904173411717.png" alt="image-20240904173411717" style="zoom:50%;" />

**通信总线 / 外部总线**：
		通信总线是用于计算机系统之间 或 计算机系统与其他系统(如远程通信设备、测试设备)之间信息传送的总线。	

**I/O总线**：
		I/O总线主要用于连接中低速的I/O设备，通过I/O接口与系统总线相连接
		目的是将低速设备与高速总线分离，以提升总线的系统性能
		常见的有USB、PCI总线、键盘

**3.按时序控制方式**
同步总线
异步总线

### **系统总线的结构** 

**单总线结构** 
结构：CPU、主存、IO设备（通过IO接口）都连接在**一组**总线上，
			允许I/O设备之间、I/O设备和CPU之间或I/O设备与主存之间直接交换信息。
优点：结构简单，成本低，易于接入新的设备。
缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。

PS：一组总线并不是一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线。

 			<img src="E:\图片\图床\image-20240314224520330.png" alt="image-20240314224520330" style="zoom:67%;" />			



**双总线结构** 
	结构：双总线结构有两条总线，
				一条是<font color='red'>主存总线</font>，用于CPU、主存和通道之间进行数据传送
					另一条是<font color='red'>I/O总线</font>，用于多个外部设备与通道之间进行数据传送。
	优点：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离。
	缺点：需要增加<font color='red'>通道</font>等硬件设备。

​	支持突发(猝发)传送：送出一个地址，收到多个地址连续的数据。

PS：通道是具有特殊功能的CPU，能对I/O设备进行统一管理。通道程序放在主存中。

 <img src="E:\图片\图床\image-20240314224907955.png" alt="image-20240314224907955" style="zoom:67%;" />

**三总线结构** 

结构：三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路
			这3条总线分别为<font color='red'>主存总线</font>、<font color='red'>I/O总线</font>和<font color='red'>直接内存访问DMA总线</font>。

 <img src="E:\图片\图床\image-20240314225217334.png" alt="image-20240314225217334" style="zoom:67%;" />

优点：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。
缺点：系统工作效率较低。【同一时刻，只能有一个总线工作，剩余两个总线空闲】

**四总线结构** 

 <img src="E:\图片\图床\image-20240314225452761.png" alt="image-20240314225452761" style="zoom:67%;" />

1.桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能
2.靠近CPU的总线速度快
3.每级总线的设计遵循总线标准

## 总线性能指标

**1.总线的传输周期（总线周期）** 
	一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成

​	总线周期和总线时钟周期，可能是一对一、一对多、多对一的关系

**2.总线时钟周期（机器的时钟周期）**
	计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制 

​	现在的计算机中,总线时钟周期也有可能由桥接器提供

**3.总线的工作频率** 
	总线上各种操作的频率，为总线周期的倒数。若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。
	实际上指**一秒内传送几次数据**。

**4.总线的时钟频率（机器的时钟频率）** 
	为时钟周期的倒数。若时钟周期为T，则时钟频率为1/T。
	实际上指**一秒内有多少个时钟周期**。

**5.总线宽度（总线位宽）** 
	它是总线上<font color='red'>同时能够传输的数据位数</font>，通常是指<font color='red'>数据总线的根数</font>，如32根称为32位（bit）总线。

**6.总线带宽** 
	可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数
	通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。
<img src="E:\图片\图床\image-20240314232248200.png" alt="image-20240314232248200" style="zoom:67%;" />

​	总线带宽是指总线本身所能达到的<font color='red'>最高传输速率</font>。
​	在计算实际的**有效数据传输率**时，要用实际传输的数据量除以耗时。

![image-20240314232646878](E:\图片\图床\image-20240314232646878.png)

**<font color='red'>每个时钟周期传送两次数据——> 1个时钟周期 = 2个总线周期</font>** 
若 时钟周期=N * 总线周期——>工作频率 =N * 时钟频率

**7.总线复用** 
	总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。

​	<img src="E:\图片\图床\image-20240314232929798.png" alt="image-20240314232929798" style="zoom: 33%;" /> 会导致速度下降

**8.信号线数** 
	地址总线、数据总线、控制总线3种总线数的总和称为信号线数

## 总线操作和定时

操作和定时——占用总线的一对设备如何进行数据传输

### **总线周期的四个阶段** 

**申请分配阶段**：由需要使用总线的主模块(或主设备)提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为<font color='red'>传输请求</font>和<font color='red'>总线仲裁</font>两个阶段。
**寻址阶段**：获得使用权的主模块通过总线<font color='red'>发出</font>本次要访问的<font color='red'>从模块的地址</font>以及有关<font color='red'>命令</font>，启动参与本次传输的从模块
**传输阶段**：主模块和从模块进行数据交换，可单向或双向进行数据传送
**结束阶段**：主模块的<font color='red'>有关信息</font>均从系统总线上<font color='red'>撤出</font>，让出总线使用权

**总线定时**：总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，实质是一种协议或规则

### **同步通信(同时定时方式)** 

总线控制器采用一个**统一的时钟信号**来协调发送和接收双方的传送定时关系。

若干个时钟产生相等的时间间隔，每个间隔构成一个总线周期。

在一个总线周期中，发送方和接收方可进行一次数据传送。

因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。

优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。
缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。

同步通信适用于**总线长度较短**及**总线所接部件的存取时间比较接近**的系统。



### **异步通信(异步定时方式)** 

采用**应答方式**，没有公共时钟标准

在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制
主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号

优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。
缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。

根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型。
**1）不互锁方式** 
	主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。
	而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系。

**2）半互锁方式** 
	主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。
	而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。

**3）全互锁方式** 
	主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号;有互锁的关系。
	从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。	

### **半同步通信**

半同步通信：统一时钟的基础上，增加一个“等待”响应信号<img src="E:\图片\图床\image-20240315084353644.png" alt="image-20240315084353644" style="zoom:80%;" /> 

同步：**发送方**用系统**时钟前沿**发信号
			**接收方**用系统**时钟后沿**判断、识别 

异步：允许不同速度的模块和谐工作

### **分离式通信** 

上述三种通信的共同点
一个总线传输周期（以输入数据为例)
	主模块发地址、命令			**使用总线** 
	从模块准备数据					**不使用总线**	**总线空闲** 
	从模块向主模块发数据		**使用总线** 

分离式通信的一个总线传输周期分为两个子周期 
	子周期1：**主模块**申请**占用总线**，使用完后**放弃总线**的使用权
	子周期2：**从模块**申请**占用总线**，将各种信息送至总线上

特点:
	1.各模块均有权申请占用总线
	2.采用**同步方式通信**，不等对方回答
	3.各模块准备数据时，不占用总线
	4.总线利用率提高



# 第七章——输入输出系统

## 基本概念

### **I/O接口 ** 

I/O接口：又称I/O控制器、设备控制器，负责协调主机与外部设备之间的数据传输
		I/O控制器就是一块芯片常被集成在主板上
		现在的I/O接口(芯片)也会被集成在南桥芯片内部

<img src="E:\图片\图床\image-20240315155025354.png" alt="image-20240315155025354" style="zoom:67%;" />

CPU如何控制键盘I/O的完成？
	①**程序查询方式** 
			CPU不断轮询检查I/O控制器中的“状态寄存器”，检测到状态为“已完成”之后，再从数据寄存器取出输入数据
	②**程序中断方式** 
			等待键盘I/O时CPU可以先去执行其他程序，键盘I/O完成后I/O控制器向CPU发出中断请求，CPU响应中断请求，并取走输入数据
			CPU处理中断服务程序，实现I/O与主机之间的传送

上述数据流：键盘—>IO接口的数据寄存器—>数据总线—><u>CPU某寄存器</u>—>主存（变量i的对应位置）



### **DMA控制方式** 

 <img src="E:\图片\图床\image-20240315155426876.png" alt="image-20240315155426876" style="zoom:67%;" />

DMA接口，即DMA控制器，也是一种特殊的I/O控制器

DMA控制方式：
		主存与高速I/O设备之间有一条<font color='red'>直接数据通路</font>（DMA总线）。
		CPU向DMA接口发出“读/写”命令，并指明主存地址、磁盘地址、读写数据量等参数。

DMA控制器自动控制磁盘与主存的数据读写，<font color='red'>每完成一整块数据读写</font>（如1KB为一整块），<font color='red'>才向CPU发出一次中断请求</font>。
DMA控制器与主存每次传送1个字。当传送完一整块数据后才向CPU发出中断请求

**PS：**当DMA对主存进行读写操作时，CPU不能再对主存读写

### **通道控制方式** 

通道是具有特殊功能的处理器，能对I/O设备进行统一管理。

通道：可以理解为是“<font color='red'>弱化版的CPU</font>”。通道可以识别并执行一系列<font color='red'>通道指令</font>，通道指令种类、功能通常比较单一。

<img src="E:\图片\图床\image-20240315161014516.png" alt="image-20240315161014516" style="zoom: 50%;" />



### I/O**系统基本组成** 

I/O系统由I/O软件和I/O硬件两部分构成

**I/O硬件**	包括外部设备、I/O接口、I/O总线等
		<img src="E:\图片\图床\image-20240315161416299.png" alt="image-20240315161416299" style="zoom:67%;" />

**I/O软件**	包括驱动程序、用户程序、管理程序、升级补丁等

​	通常采用I/O指令和通道指令实现主机和I/O设备的信息交换。

<font color='blue'>I/O指令</font>（CPU指令的一部分，对数据缓冲寄存器、状态/控制寄存器的访问操作）【通用寄存器和IO端口的数据传送】
		I/O指令由操作码、命令码、设备码组成
			操作码——识别I/O指令【CPU对IO接口操作】
			命令码——做什么操作【IO接口对设备操作】
			设备码——对哪个设备进行操作
<img src="E:\图片\图床\image-20240315162135364.png" alt="image-20240315162135364" style="zoom:50%;" />
I/O指令只能在操作系统内核的底层I/O软件中使用，是一种**特权指令**。

<font color='blue'>通道指令</font>（通道能识别的指令）
	<font color='red'>通道程序</font>提前编制好放在<font color='red'>主存中</font> 

​	在含有通道的计算机中，CPU执行<font color='red'>I/O指令</font>对通道发出命令，由通道执行一系列<font color='red'>通道指令</font>，代替CPU对I/O进行管理

### **外部设备** 

输入设备——鼠标、键盘
输出设备——显示器、打印机
外存设备/既可输入又可输出——硬盘、光盘

**显示器** 

灰度级： n位可以表示2^n^种不同的亮度或颜色

刷新频率：单位时间内扫描整个屏幕内容的次数。通常显示器刷新频率在60~120Hz

<u>显示存储器VRAM</u>——也称为刷新存储器。
			VRAM容量 = 分辨率 * 灰度级位数【n位可表示2^n^种颜色/亮度】【一帧的大小为显存的理论最小值】
			VRAM带宽 = 分辨率 * 灰度级位数 * 帧频

现代计算机中，显存大的原因——显存除了作为当前显示帧的缓存，还会用于保存即将渲染的图像数据。
集成显卡计算机中，通常分配一片内存作为显存

阴极射线管显示器  CRT——字符显示器、图形显示器(线段、波段)【光栅扫描显示器、随机扫描显示器】、图像显示器
		<u>字符显示器</u>：字符的ASCII码被存放到视频存储器VRAM中，在字符发生器ROM中有ASCII对应的字符码
								每个字的字形码大小为m * n bit【点阵由m*n个点组成的阵列】
		图形显示器：显示线段
		图像显示器：按照扫描方式分为——光栅扫描显示器、随机扫描显示器

液晶显示器  LCD【利用液晶的电光效应】
发光二极管显示器  LED【通过控制半导体发光二极管】



**打印机** 

按印字原理不同：
	击打式打印机：防伪效果好、成本低、质量好。噪声大、速度慢。
	非击打式打印机：速度快、噪声小。成本高。

按打印方式不同：
	串行打印机：逐字打印
	行式打印机：逐行打印

按工作方式：
	针式打印机
	喷墨式打印机
	激光打印机

## I/O接口

I/O接口：又称I/O控制器、设备控制器，负责协调主机与外部设备之间的数据传输
	有的I/O接口可以连接多个设备

<img src="E:\图片\图床\image-20240315155025354.png" alt="image-20240315155025354" style="zoom:67%;" />

### **作用** 

​	①**数据缓冲**：通过数据缓冲寄存器DBR达到主机和外设工作速度的匹配
​	②**错误或状态检测**：通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用
​	③**控制和定时**：接受从控制总线发来的控制信号、时钟信号
​	④**数据格式转换**：串—并、并—串等格式转换【外设到I/O接口一般为串行。CPU和I/O接口一般为并行】
​	⑤**与主机和设备通信**：实现 主机—I/O接口—I/O设备之间的通信
​	⑥**进行地址译码和设备选择**：CPU送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息

内部接口：内部接口与系统总线相连，实质上是与内存、CPU相连。串行和并行都有。
外部接口：外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，因此IO接口需要具有串并转换能力

IO接口可以一对一，一对多。

### **工作原理** 

①发命令：发送<font color='red'>命令字/控制字</font>到I/O控制寄存器，向设备发送命令（需要驱动程序的协助)
②读状态：从状态寄存器读取<font color='red'>状态字</font>，获得设备或I/O控制器的状态信息
③读写数据：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换
 <img src="E:\图片\图床\image-20240315180852606.png" alt="image-20240315180852606" style="zoom:67%;" />   

<font color='red'>控制寄存器、状态寄存器</font>在<font color='red'>使用时间上是错开</font>的，因此有的I/O接口可将二者合二为一
中断类型号/中断向量地址：区分是中断请求还是故障

I/O控制器中的各种寄存器称为<font color='red'>I/O端口</font> 

**如何确定要操作的设备?** 
	1.每个设备对应一组寄存器，操作不同的寄存器就是在操作不同的设备
	2.用地址线指明，寻设备和寄存器分两次传

​	

### **接口与端口** 

I/O端口是指接口电路中可以被CPU直接访问的寄存器。
I/O端口若想被CPU访问，必须要有端口地址，每一个端口对应一个端口地址

 <img src="E:\图片\图床\image-20240315181020577.png" alt="image-20240315181020577" style="zoom:50%;" />

#### 统一编制/存储器映射方式

 <img src="E:\图片\图床\image-20240315181151468.png" alt="image-20240315181151468" style="zoom:50%;" /> 靠<font color='red'>不同的地址码</font>区分内存和I/O设备。**访存类的指令都可以访问I/O端口**【**RISC机器常用**】

 <img src="E:\图片\图床\image-20240315181712897.png" alt="image-20240315181712897" style="zoom: 67%;" /> 

优点：不需要专门的输入/输出指令，所有访存指令都可直接访问端口，程序设计灵活性高。
			 端口有较大的编制空间
		 	读写控制逻辑电路简单
缺点：端口占用了主存地址空间，使主存地址空间变小
			外设寻址时间长（地址位数多，地址译码速度慢）

#### 独立编址/IO映射

 <img src="E:\图片\图床\image-20240315181523253.png" alt="image-20240315181523253" style="zoom:50%;" />    ![image-20240315181546201](E:\图片\图床\image-20240315181546201.png)   

优点：使用专用I/O指令，程序编制清晰
			I/O端口地址位数少，地址译码速度快
			I/O端口的地址不占用主存地址空间
缺点：I/O指令类型少，一般只能对端口进行传送操作，程序设计灵活性差
			需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制逻辑电路的复杂性

### **I/O接口类型** 

**按数据传送方式** 
	并行接口：一个字节或一个字所有位同时传送。
	串行接口：一位一位地传送。

这里所说的数据传送方式指的是外设和接口一侧的传送方式。主机和接口一侧可能是串行也可能是并行。
接口要完成数据格式转换。

**按主机访问I/O设备的控制方式可分为**
	程序查询接口
	中断接口
	DMA接口

**按功能选择的灵活性可分为**
	可编程接口
	不可编程接口

①**<font color='blue'>磁盘驱动器向盘片磁道记录数据时采用<font color='red'>串行</font>方式写入</font >**。
②<font color='blue'>**磁盘驱动器/磁盘，不是IO接口**</font>。
③<font color='blue'>**IO总线中的数据线宽度和连接设备的电缆中的数据线宽度不一定相同**</font>。
④<font color='blue'>**中断请求信号不在控制接口和打印机之间交换——中断请求信号是控制接口通过中断控制器发给CPU的**</font>。

## I/O方式

### **程序查询方式** 

两种程序查询方式
	①独占查询：CPU 100%的时间都在查询I/O状态，完全串行
					<img src="E:\图片\图床\image-20240315205130856.png" alt="image-20240315205130856" style="zoom: 50%;" />
	②定时查询：在【保证数据不丢失】的情况下，每隔一段时间CPU就查询一次I/O状态
							 查询的间隔内CPU可以执行其他程序

IN Rd，Rs：把IO端口Rs的数据输入到CPU寄存器Rd
OUT Rd	Rs：把CPU寄存器Rs的数据输出到IO端口Rd 
例子：打印3个字符

执行顺序
	①将CPU中的寄存器中的内容，OUT到R~n+1~端口【此次输出为“打印”的命令字】
	②CPU发出打印请求后，一直轮询检查状态寄存器是否处于Ready状态。【将状态寄存器中的值IN到CPU寄存器中】
	②I/O控制逻辑给打印机发出控制信号。打印机收到信号后，开始启动
	③启动成功后，打印机通过状态线给I/O接口一个反馈，将Ready状态存入到状态寄存器中
	④CPU通过地址线指明此次要操作的是R~n~端口，控制线指明此次操作为写操作
	⑤将数据a写入到数据缓冲寄存器中
	⑥通过I/O控制逻辑把数据输出到打印机
	⑦打印机处于忙，状态寄存器忙信号	
	⑧当打印完成后再次将状态寄存器改为Ready/Finish状态

![image-20240315210711994](E:\图片\图床\image-20240315210711994.png)

![image-20240315210811650](E:\图片\图床\image-20240315210811650.png)

![image-20240315211618437](E:\图片\图床\image-20240315211618437.png)

### **中断** 

程序中断：在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去					对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。

中断响应周期：当CPU采用中断方式实现主机与I/O交换信息时，<font color='red'>**CPU在每条指令执行阶段结束前，都要发中断查询信号**</font>							 以检测是否有某个I/O提出中断请求。如果有请求，CPU则要进入中断响应阶段，又称中断周期。

#### 工作流程

​	**1.中断请求**
​		中断源向CPU发送中断请求信号。
​	**2.中断响应**
​		响应中断的条件。
​		中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。
​	**3.中断处理**
​		中断隐指令。【中断响应】【中断隐指令指令部分不可用软件实现，无法预判中断的发生】
​		中断服务程序。

若系统处于关中断状态时，不会响应任何中断请求
			IF=1 表示 开中断（允许中断）
			IF=0 表示 关中断（不允许中断）
【关中断作用：实现原子操作（在一段指令中前面关中断，最后关中断。从而使得此段指令不会被中断）】

非屏蔽中断：关中断时也会被响应（如：掉电）
可屏蔽中断：关中断时不会被响应

#### **中断请求标记**  

每个中断源向CPU发出中断请求的时间是随机的。
为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置<font color='red'>中断请求标记触发器INTR</font>，当其状态为“1"时，表示中断源有请求。
这些触发器可组成**中断请求标记寄存器**。**该寄存器可集中在CPU中，也可分散在各个中断源中**。

![image-20240316080755033](E:\图片\图床\image-20240316080755033.png)

对于**外中断**，CPU是在统一的时刻即**每条指令执行阶段结束前**向接口**发出中断查询信号**，以获取I/O的中断请求。
也就是说，**CPU响应中断的时间**是在每条**指令执行阶段的结束时刻**。

CPU响应中断必须满足以下3个条件:
	①中断源有中断请求。
	②CPU允许中断即开中断。
	③一条指令执行完毕，且没有更紧迫的任务。

#### 中断判优

**中断判优**既可以用硬件实现，也可用软件实现:
硬件实现是通过<font color='red'>硬件排队器</font>实现的，它既可以设置在CPU中，也可以分散在各个中断源中【固定优先级】
软件实现是通过<font color='red'>查询程序</font>实现的。

**优先级设置** 

​	①硬件故障中断＞软件中断【硬件故障中断为最高级中断】
​	②非屏蔽中断＞可屏蔽中断
​	③DMA请求＞I/O设备传送的中断请求
​	④高速设备＞低速设备;
​	⑤输入设备＞输出设备
​	⑥实时设备＞普通设备

#### 中断处理过程

​	**中断隐指令**：保存原程序的PC值；并让PC指向中断服务程序的第一条指令【CPU/硬件自动完成】

​	**中断隐指令的主要任务**：
​			①<font color='red'>关中断</font>。在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，
​								必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。
​			②<font color='red'>保存断点</font>。PC值可以存入**堆栈**，也可以存入指定单元【<font color='blue'>异常断点为当前指令地址，中断断点为下一条指令地址</font>】 
​			③<font color='red'>引出中断服务程序</font>。引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器(PC) 

**如何确定中断服务程序的起始地址？**
	软件查询法
	硬件向量法：由<font color='red'>硬件</font>产生<font color='red'>向量地址</font>，再由<font color='red'>向量地址</font>找到<font color='red'>入口地址</font>   【向量地址 也称为 中断类型号】
			<img src="E:\图片\图床\image-20240315215923118.png" alt="image-20240315215923118" style="zoom:50%;" />



**中断服务程序的主要任务：** 
	①<font color='red'>保护现场</font>。保存**通用寄存器和状态寄存器的内容**（保存ACC寄存器的值），以便返回原程序后可以恢复CPU环境。							可使用堆栈，也可以使用特定存储单元。
	②<font color='red'>中断服务(设备服务)</font> 。主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中
											（eg:中断服务的过程中有可能修改ACC寄存器的值)
	③<font color='red'>恢复现场</font>。通过出栈指令或取数指令把之前保存的信息送回寄存器中(eg:把原程序算到一般的ACC值恢复原样)	
	④<font color='red'>中断返回</font>。通过中断返回指令回到原程序断点处。


单重中断：执行中断服务程序时不响应新的中断请求。


#### 多重中断

多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。

 <img src="E:\图片\图床\image-20240315224516083.png" alt="image-20240315224516083" style="zoom:50%;" />

**中断屏蔽技术** 

中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件。
	①在中断服务程序中提前设置开中断指令。
	②优先级别高的中断源有权中断优先级别低的中断源。

​	每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请。
​	所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，<font color='red'>屏蔽字寄存器的内容称为屏蔽字</font>。
​	屏蔽字中‘1’越多，优先级越高。每个屏蔽字中至少有一个‘1’(至少要能屏蔽自身的中断)。

中断屏蔽标志——改变多个中断服务程序执行完的次序![image-20240315225810964](E:\图片\图床\image-20240315225810964.png)

关于屏蔽字——处理次序大于自己的标为0【正常申请，不可屏蔽】



### **程序中断方式** 

![image-20240315230927610](E:\图片\图床\image-20240315230927610.png)

![image-20240315231326736](E:\图片\图床\image-20240315231326736.png)

CPU会花时间来处理中断服务程序，CPU利用率严重降低，因此采用DMA方式

### **DMA方式** 

<img src="E:\图片\图床\image-20240315231413917.png" alt="image-20240315231413917" style="zoom:70%;" />

<img src="E:\图片\图床\image-20240315231639814.png" alt="image-20240315231639814" style="zoom: 67%;" />

①接受<font color='red'>外设发出的DMA请求</font>（外设传送一个字的请求），并向CPU发出总线请求。
②CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。
③确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。
④规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。
⑤向CPU报告DMA操作的结束。【中断信号】
【①②为传送前，③④为传送中，⑤为传送后】

<img src="E:\图片\图床\image-20240316090522520.png" alt="image-20240316090522520" style="zoom: 48%;" /><img src="E:\图片\图床\image-20240910165423848.png" alt="image-20240910165423848" style="zoom: 51%;" />

控制/状态逻辑：由控制和时序电路及状态标志组成
							  用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。
DMA请求触发器：每当I/O设备准备好数据后给出一个控制信号，使DMA请求触发器置位。
数据缓冲寄存器：用于暂存每次传送的数据。
传送长度计数器WC：用来记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。
主存地址计数器AR：存放要交换数据的主存地址。

**在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线，CPU主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。** 

#### **DMA传送方式**

主存和DMA控制器之间有一条数据通路，因此主存和I/O设备之间交换信息时不通过CPU。
但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效使用主存，DMA控制器与CPU通常采用3种方法使用主存。
PS：只有三总线时才会出现DMA和CPU同时访问主存。单总线时DMA是否能访问主存都是CPU说的算。

<img src="E:\图片\图床\image-20240316094856946.png" alt="image-20240316094856946" style="zoom:67%;" />

**1.停止CPU访问内存** 
<img src="E:\图片\图床\image-20240316094400985.png" alt="image-20240316094400985" style="zoom:67%;" />

优点：控制简单
缺点：CPU处于不工作状态或保持状态
			未充分发挥CPU对主存的利用率

**2.DMA与CPU交替访存** 

 <img src="E:\图片\图床\image-20240316094522085.png" alt="image-20240316094522085" style="zoom:67%;" />

优点：不需要总线使用权的申请、建立和归还过程
缺点：硬件逻辑更为复杂

**3.周期挪用（存取周期窃取） ** 

 <img src="E:\图片\图床\image-20240316094709370.png" alt="image-20240316094709370" style="zoom: 67%;" /> 此周期是主存的存取周期

DMA访问内存有三种可能：
		CPU此时不访存（不冲突)
		CPU正在访存（存取周期结束让出总线)
		CPU与DMA同时请求访存(I/O访存优先)

**DMA方式具有下列特点:**
①它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。
②在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。
③主存中要开辟专用缓冲区，及时供给和接收外设的数据。
④DMA传送速度快，CPU和外设并行工作，提高了系统效率。
⑤DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。

由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，<font color='red'>I/O与主机并行工作，程序和传送并行工作</font>。

#### DMA和中断方式的区别

<img src="E:\图片\图床\image-20240316095010378.png" alt="image-20240316095010378" style="zoom:67%;" />

从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送
中断传送过程需要CPU的干预。而DMA传送过程不需要CPU的干预，因此数据传输率非常高。
中断I/O的数据传送用软件完成，DAM方式的数据传送由硬件完成

![image-20240316145959760](E:\图片\图床\image-20240316145959760.png)

​	中断周期前是执行周期，中断周期后是下一条指令的取指周期。
​	DMA周期前可以是取指周期、间址周期、执行周期或中断周期，DMA周期后也可以是取指周期、间址周期、执行周期或中断周期。总之，DMA周期前后都是机器周期。



## IO强化

### 从中断控制器来看中断过程

**中断响应优先级**：用于中断判优
**中断处理优先级**：用于发出中断查询【中断屏蔽字】

<img src="E:\图片\图床\image-20241020211210002.png" alt="image-20241020211210002" style="zoom: 80%;" />

PS：**中断响应的时间点和异常处理的时间点不同**：
			中断是在一条指令执行结束后开始查询有无中断请求，一定在指令执行完时响应中断。
			异常发生在指令执行期间，所以不能等到指令执行完才进行异常处理。

<img src="E:\图片\图床\image-20241020212214284.png" alt="image-20241020212214284" style="zoom:80%;" />

2的处理优先级高于3的处理优先级，因此在执行期间2会将3屏蔽。所以，只有当2执行完后，返回到用户程序再去执行3。

### Printf

printf是C语言中的库函数，属于用户层I/O软件。

过程：
	第一阶段——由库函数完成
		①申请一个字符数组(传参)
		②系统调用
	第二阶段——进入内核态执行
	第三阶段——返回到用户态

系统调用可以通过下面三种IO方式实现

**1.轮循方式**	
	将字符串复制到内核缓冲区。
	不直接使用用户缓冲区原因：系统调用函数位于内核态，需要把用户缓冲区中的内容复制到内核空间。

​	通过设备驱动程序，与IO端口交互信息
​	用户态——>内核态——>驱动程序

**2.中断驱动方式** 
	<img src="E:\图片\图床\image-20241020214422997.png" alt="image-20241020214422997" style="zoom:80%;" />

过程：
	将字符串复制到内核缓冲区——>开中断——>等待就绪状态——>向数据端口发送字符——>发送启动输出命令

在进入内核态时会关中断

**中断和轮循方式下的系统调用最本质的区别**：中断方式下，仅仅是把第一个字符放入数据寄存器中，然后就不管了，至于这个字符何时打印出来，以及剩余的字符如何打印出来就不是系统调用函数的任务了。

**设备驱动程序和中断处理程序全部在同一个进程中运行吗**？
	设备驱动程序一定有一部分是在发起系统调用的进程A当中执行的，而中断处理程序则一定不是在进程A中执行，取决于CPU响应中断时正在执行哪个进程

**以上过程中，如果不采用内核缓冲区，直接使用用户缓冲区会发生什么问题**？
	中断服务程序在运行的时候，是在进程B的资源平台上，进程B的页表与进程A的页表是不同的，而用户缓冲区buf是进程A中的地址，它不能用进程B的页表页表来进行地址映射。而内核缓冲区中的数据，无论是进程A还是进程B，它们的内核地址空间中的内容都是相同的，因此能顺利的访问。

**以上过程中，设备驱动程序在哪些过程中体现的？是以单独的进程的形式存在的吗**？
	驱动程序不是以单独的进程形式存在的，而是以内核代码和数据的形式存在。

<img src="E:\图片\图床\image-20241020215216176.png" alt="image-20241020215216176" style="zoom:67%;" />

<img src="E:\图片\图床\image-20241020215321943.png" alt="image-20241020215321943" style="zoom:67%;" />

**3.DMA方式** 

DMA控制器接受到“启动”命令后，控制总线进行DMA传送。
通常用“周期挪用法”：设备每准备好一个数据，挪用一次”存储周期“ ，使用一次总线事务进行数据传送，计数器减1。
计数器为0时，发送DMA结束中断请求

**过程：**
	字符串复制到内核缓冲区—>初始化DMA(准备参数)【驱动程序】—>发送 “启动DMA传送”命令—>阻塞用户进程P，调度其他进程执行

**DMA结束中断服务程序：**中断回答（清除中断请求）—>用户进程P解除阻塞，进入就绪队列【驱动程序】—>中断返回 

































