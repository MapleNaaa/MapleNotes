指针的概念与内存有关
是想一下，你的数据在电脑中，必定存在一个地方。如何找到这个地方呢？
这个地方有个地址。
电脑中的存储的数据必定有一个地址
那么指针就是指向这个地址
通过指针可以访问任何数据

在C语言中
```
int a ;
int *p;
p = &a
```
现在 p 指向了 a 的地址

如果
```
a = 9; // 代表a的值为9
p = 9; // 代表p指向地址为9的值
```

如果
```
p = &a 
*p = 8; // 这里的 * 代表解引用。类似于直接按照 p 所存储的地址，进去修改值了.a = 8
```


指针是一个强类型
为什么是一个强类型呢？为什么没有一个通用的指针呢？我先指向 一个int 类型，在指向一个 char 类型?

我们刚刚已经知道了 指针存储地址，同时也可以读取地址存储的数据。
那么如何读取地址存储的数据的呢？

这和 类型有关。

在回答这个问题前，我想先说一说指针的运算。

```
p = &a ; 假设 a 的地址是 205
int *p0;
p0 = p + 1; 这里的 p0 所指向的地址是多少呢？
```
是209；
为什么？
因为 int 类型在存储空间中需要四个字节表示。
所有 a 的地址虽然是 205，但是其实包含了 206，207，208
如果p0 等于 206 ， 那就相当于 p0从206到209的一共四个字节
这样会导致数据错误，所有呢，p0直接从209开始即可。

ok，现在我们在回过头看看之前的问题

不同的数据类型所需要的存储空间不同。
```
int a = 0; // a地址205
int *p = &a ; // p = 205
char *q = p ; // 这里会报错。是因为char需要1个字节，所以 q + 1 = 206，读取出的数据不对
```



当然那，指针也是一个内存变量，也是存在地址的。
```
int a = 10;  // a的地址等于200；
int *p = &a; // p = 200, p 的地址等于240；
int **q = &p; // q = 240; q 的地址等于 300;
int ***r = &q; // r = 300； r 的地址等于 400

*q = 200;
*(*q) = 10;
*r = q = 240;
*(*r) = *q = 200;
*(*(*r)) = *(*q) = *p = 10;
```

okok，指针的基本已经讲完了，现在我们来了解一下指针如何使用吧。
想必大家都听说过值传递和引用传递
```
void Upper(int a){
	a = a + 1;
}
int main(){
	int a = 10;
	Upper(a);
	printf(a) // a 是 10 还是 11？
}
```
c语言的世界里，当程序运行时，会产生一些区域
- 代码区（存放代码）
- Static/Global（静态/全局数据存放在这里）
- Stack
- Heap
其中很重要的就是Stack。
Stack存放所有程序运行过程中产生的东西。

就拿上面的代码为例。程序运行时，
首先会在stack开辟一个空间，用来存放main()函数，这被称为栈帧。
那么，你在main() 中定义了一个变量 a 。那在stack区域里，a肯定位于main()所归属的那块地方。
ok，现在你要调用Upper函数了。
那么在stack里面，会先暂停main()函数的运行，开辟一块空间给upper()。
upper接受到了一个值a
那会在upper内部的空间会有一块地方属于 a，对应的值为接受的值。
注意，这里已经是一个新的地方了储存a的值了，和原来的a已经没有了任何关系。
所以，在main()的a的值依旧是10.

主播主播，这样讲述还是太吃操作了，有没有更加简单的方法？
有的有的，这就是引用传递。

指针本质上是储存的地址对吧。
刚刚两个函数之间的联系，就只是传参，对吧。
那么如果我把main()里面的地址，传到upper里面，这不就可以了吗？

上面的代码可以改写成这样
```
void Upper(int* p){
	*p = *p + 1;
}
int main(){
	int a = 10;
	Upper(&a);
	printf(a) // a 是 10 还是 11？
}
```
在upper里面，直接对main()里的空间进行操作，这样不就解决了二者没有联系的问题了吗？

由此可以解决笔者初学C时的一个疑惑。
```
int a;
scanf(&a); 
printf(a); // 为什么scanf要加&a，而printf不用
```
现在一切就很明了。


讲了函数，接下来我们在讲一下数组。
```
int A[] = {1,2,3,4,5};
// 其中A[0]地址是204，则A[4]地址是204 + 4 * 4 = 220.每int占据4byte
```
数组本质上也是开辟空间，不过是一连串连续的空间。

那数组如何用指针表示呢？
```
int *p = A;
int *p = &A[0]; // 地址204
// 两者相等，其中 p 表示的 A 数组的首地址。
```

那这样是不是数组有一些指针的性质呢？比如说可以进行运算？
```
p++; // p 对应的值就是 208
A++; // 违法。
```
为什么违法。可以这样理解。这里的 A 其实类似于一个常量，来定义 A 这个数组的开始，是不可改变的，一旦改变， A 这个数组就起始改变，后面的地址没改变，这就会导致数据错乱。

但是我们可以不改变地址的操作。
```
printf(A[3]) // 4;
printf(*(A + 3)) // 4

int* p = A;
printf(*(p + 3)) // 4
```

