1. 递归函数时间复杂度计算方式
2. O(NlogN)排序算法




#### 1.递归函数时间复杂度计算方式 - Master公式
废话少说，先上公式
$T(N) = a * T(N/b) + O(N^d)$

其中
a:在递归函数内部，调用递归函数的次数
N/b:在递归函数内部，调用递归函数时，所用的到数据量
$O(N^d)$:在递归函数内部，非递归函数所花时间复杂度

通过这些，可以按照以下公式计算出
$log_{b}a < d \ \ 时间复杂度为，O(N^d)$
$log_{b}a > d \ \ 时间复杂度为，O(N^{log_{b}a})$
$log_{b}a = d \ \ 时间复杂度为，O(N^d * logN)$

拿我们上次写到的递归函数举例
```
void reverse(Node* cur,Node* prev){
	if(cur == NULL){
		head = prev;
		return ;
	} 
	reverse(cur->next,cur);
	cur->next = prev;
	prev = cur;
}
```
于是乎，我们可以写出，上述递归函数的对应a,b,d 值，从而计算出 时间复杂度
a = 1 


#### 2.O(NlogN)排序算法
1. [归并排序](https://www.hello-algo.com/chapter_sorting/merge_sort/)
归并排序，是通过递归实现的。
每次，从中间分开，然后分别调用并归排序。
最后必定会到极小长度 - 1 。这时候，就没有必要再次调用并归排序了，因为长度为1，就已经代表，排序完成（就自己一个，当然有序了）。
然后函数开始返回。
返回到上一层级。
此时，会得到 两个已经排序好的数组(长度为1)，对着两个数组，进行merge操作。

merge操作的意思是，将两个排序好的数组合并成为一个排序好的数组.
此时，返回。就会重复上述操作。

直接看代码吧
```
static void mergeSort(int* arr, int len) {
	_mergeSort(arr, 0, len - 1); // 注意，这里是 len - 1.
}

static void _mergeSort(int* arr, int left, int right) {
	if (left >= right) return;  // 修复终止条件

	int mid = left + ((right - left) >> 1);
	_mergeSort(arr, left, mid);
	_mergeSort(arr, mid + 1, right);

	_merge(arr, left, mid, right);
}

static void _merge(int* arr, int left, int mid, int right) {
	int* res = new int[right - left + 1];
	int idx = 0;
	int ptr1 = left;
	int ptr2 = mid + 1;
	while (ptr1 <= mid && ptr2 <= right) {
		res[idx++] = arr[ptr1] < arr[ptr2] ? arr[ptr1++] : arr[ptr2++];
	}

	while (ptr1 <= mid) {
		res[idx++] = arr[ptr1++];
	}

	while (ptr2 <= right) {
		res[idx++] = arr[ptr2++];
	}

	for (int i = 0; i < right - left + 1; i++) {
		arr[left + i] = res[i];
	}

	delete[] res; // 空间必须要释放，否则会有一直累加
}
```

这里有一些东西，需要说一下啊。

为什么 归并排序的时间复杂度为 O(NlogN) 呢？
为什么之前的那些排序算法是 O(N^2) 呢？

难道真的和多开辟的空间有关系吗？
都跟你说了多少次了，你不要盯着那个空间复杂度，他会把算法的付出给异化掉的。
哎呀，数据跑完已结算。哎呀，新开辟的空间得了MVP，算法是躺赢狗。

之前的排序，例如，选择，冒泡，插入，他们都是进行了多次比较。多次比较之后，确定了一个位置。
但是我们的归并不一样。
我们的每次比较都是有意义的。
每次比较，我们都确定了相对的大小，这些大小关系，会传递下去。
所以，时间复杂度才变为0(NlogN)


主播主播，我学会了，不就是归并排序吗，我手到擒来。

哦，这么说，小伙子你非常勇咯？
让我看看你有多勇。

前提引入一下
小数之和
arr: 1 4 2 3 5
前面比1小的数：无
前面比4小的数：1
前面比2小的数：1
前面比3小的数：1 2
前面比5小的数：1 2 3 4
小数之和为 15

如何在时间复杂度 为 O(NlogN) 的情况下，计算出小数之和？

其实呢，这道题很考验人的，需要逆向思维一下。
arr: 1 4 2 3 5
后面比1大的数：4 ，2， 3，5 四个
后面比4大的数：5 一个
后面比2大的数：3，5 两个
后面比3大的数：5 一个
后面比5大的数：无
四个1 一个4 两个2 一个3

和上面相同。

这道题其实就是在 归并排序的时候，修改一下。
