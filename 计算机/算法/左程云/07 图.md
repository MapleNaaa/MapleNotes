图的dfs
![](https://cdn.jsdelivr.net/gh/Maple819/PicGo@main/img/20250323194536411.png)

非递归版本：
```cpp
class Solution {
public:
    struct Node {
        vector<Node*> nexts;
    };

    bool dfs(Node* node, Node* tar) {
        if (node == nullptr || tar == nullptr)
            return false;
        if(node == tar) return true;
        stack<Node*> stk;
        unordered_set<Node*> set;
        stk.push(node);                    
        set.insert(node);
        Node* cur;
        while (!stk.empty()) {
            cur = stk.top();
            stk.pop();
            for (Node* next : cur->nexts) {
                if (next == tar)
                    return true;
                if (!set.contains(next)) {
                    // stk.push(cur);
                    stk.push(next);
                    set.insert(next);
                }
            }
        }
        return false;
    }

    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        // vector<Node*> nodes;
        if(source == destination) return true;
        vector<Node*> nodes(n,nullptr);

        for (auto edge : edges) {
            int x = edge[0];
            int y = edge[1];
            if (nodes[x] == nullptr)
                nodes[x] = new Node();
            if (nodes[y] == nullptr)
                nodes[y] = new Node();
            nodes[x]->nexts.push_back(nodes[y]);
            nodes[y]->nexts.push_back(nodes[x]);
        }

        return dfs(nodes[source], nodes[destination]);
    }
};
```

递归版本:
```cpp
class Solution {
public:
    struct Node {
        bool visited = false;
        vector<Node*> nexts;
    };

    bool dfs(Node* node, Node* tar) {
        if (node == tar)
            return true;
        node->visited = true;
        for (Node* next : node->nexts) {
            if (!next->visited && dfs(next, tar))
                return true;
        }
        return false;
    }

    bool validPath(int n, vector<vector<int>>& edges, int source,
                   int destination) {
        // vector<Node*> nodes;
        if (source == destination)
            return true;
        vector<Node*> nodes(n, nullptr);

        for (auto edge : edges) {
            int x = edge[0];
            int y = edge[1];
            if (nodes[x] == nullptr)
                nodes[x] = new Node();
            if (nodes[y] == nullptr)
                nodes[y] = new Node();
            nodes[x]->nexts.push_back(nodes[y]);
            nodes[y]->nexts.push_back(nodes[x]);
        }

        return dfs(nodes[source], nodes[destination]);
    }
};
```

bfs
非递归版本
```cpp
class Solution {
public:
    struct Node {
        vector<Node*> nexts;
        bool visited = false;
    };

    bool bfs(Node* node, Node* tar) {
        if (node == nullptr || tar == nullptr)
            return false;
        if (node == tar)
            return true;
        queue<Node*> que;
        // unordered_set<Node*> set;
        que.push(node);
        node->visited = true;

        while (!que.empty()) {
            Node* cur = que.front();
            que.pop();
            for (Node* next : cur->nexts) {
                if (next == tar)
                    return true;
                if (!next->visited) {
                    que.push(next);
                    next->visited = true;
                }
            }
        }

        return false;
    }

    bool validPath(int n, vector<vector<int>>& edges, int source,
                   int destination) {
        // vector<Node*> nodes;
        if (source == destination)
            return true;
        vector<Node*> nodes(n, nullptr);

        for (auto edge : edges) {
            int x = edge[0];
            int y = edge[1];
            if (nodes[x] == nullptr)
                nodes[x] = new Node();
            if (nodes[y] == nullptr)
                nodes[y] = new Node();
            nodes[x]->nexts.push_back(nodes[y]);
            nodes[y]->nexts.push_back(nodes[x]);
        }

        return bfs(nodes[source], nodes[destination]);
    }
};
```

![](https://cdn.jsdelivr.net/gh/Maple819/PicGo@main/img/20250323214058675.png)

```cpp
class Solution {
public:
    struct Node {
        vector<Node*> nexts;
    };

    int ans = 0;

    void dfs(int k, Node* node, Node* tar, int count) {
        if (count == k) {
            if (node == tar)
                ans++;
            return;
        }

        for (Node* next : node->nexts) {
            dfs(k, next, tar, count + 1);
        }
    }

    int numWays(int n, vector<vector<int>>& relation, int k) {
        vector<Node*> nodes(n, nullptr);
        for (auto edge : relation) {
            int fp = edge[0], tp = edge[1];
            if (nodes[fp] == nullptr)
                nodes[fp] = new Node();
            if (nodes[tp] == nullptr)
                nodes[tp] = new Node();
            nodes[fp]->nexts.push_back(nodes[tp]);
        }
        dfs(k, nodes[0], nodes[n - 1], 0);
        return ans;
    }
};
```