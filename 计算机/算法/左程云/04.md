1. 算法总结
2. 链表数通

#### 1.算法总结
目前我们已经学了很多排序算法了。
也是时候该做一个总结了。
不过在此之前，我想再引入一个概念：
算法的稳定性

什么是算法的稳定性呢？
即答:元素排序之后相对次序保持不变

| 算法   | 时间复杂度        | 空间复杂度       | 稳定性 |
| ---- | ------------ | ----------- | --- |
| 选择排序 | $O(N^2)$     | $O(1)$      | ×   |
| 冒泡排序 | $O(N^2)$     | $O(1)$      | √   |
| 插入排序 | $O(N^2)$     | $O(1)$      | √   |
| 归并排序 | $O(Nlog(N))$ | $O(N)$      | √   |
| 快速排序 | $O(Nlog(N))$ | $O(log(N))$ | ×   |
| 堆排序  | $O(N^2)$     | $O(1)$      | ×   |
| 计数排序 | $O(N)$       | $O(N*b)$    | √   |
| 基数排序 | $O(N)$       | $O(N)$      | √   |

关于稳定性实现：
1. 冒泡排序:即当元素相同的，不交换
```
for(int i = 0 ; i < len - 1 ; i++){
	for(int j = 0; j < len - 1 - i ; j++){
		if(arr[j] > arr[j + 1])
			swap(arr,j,j + 1)
	}
}
```
2. 插入排序:即当元素相同的，不交换
```
for(int i = 1 ; i < len ; i++){
	for(int j = i - 1; j >= 0 && arr[j] > arr[j + 1] ; j--)
		swap(arr, j , j + 1)
}
```
3. 归并排序:
```
void mergeSort(int* arr , int left, int right){
	if(left >= right) return;

	int mid = left + ((mid - left) >> 1);
	mergeSort(arr,left,mid);
	mergeSort(arr,mid + 1, right);

	merge(arr,left, mid, right);
}

void merge(int* arr, int left ,int mid ,int right){
	int* help = new int[right - left + 1];
	int ptr1 = left;
	int ptr2 = mid + 1;
	int idx = 0;
	
	while(ptr1 <= mid && ptr2 <= right){
		help[i++] = arr[ptr1] < arr[ptr2] ? arr[ptr1++] : arr[ptr2++];
	}

	while(ptr1 <= mid) help[i++] = arr[ptr1++];
	while(ptr2 <= right) help[i++] = arr[ptr2++];

	for(int i = 0; i < right - left + 1 ;i++) arr[left + i] = help[i];

	delete[] help;
}
```


#### 2.链表速通
这里咱们就尽量速通链表嗷，代码啥的就自己复现一下。

单链表基本上就是关于数据结构和快慢指针的应用
如何应用呢？

链表问题，只要是和值有关的，其实可以转化成为数组问题。

其次，和地址相关的，可以尝试使用哈希表。

那快慢指针又是什么说法？

来看一个例题
leetcode234
![](https://cdn.jsdelivr.net/gh/Maple819/PicGo@main/img/20250318211846509.png)

```
bool isPalindrome(ListNode* head) {
	int len = 0;
	ListNode* ptr = head;

	while(ptr != nullptr){
		ptr = ptr->next;
		len++;
	}
	
	int* help = new int[len];
	ptr = head;

	for(int i = 0; i < len ; i++){
		help[i] = ptr->val;
		ptr = ptr->next;
	}

	for(int i = 0, j = len - 1; i <= j ; i++, j--){
		if(help[i] != help[j]) return false;
	}

	return true;
}
```