#### 1.高精度加法
```cpp
vector<int> highAdd(vector<int>& a, vector<int>& b) {
	vector<int> c;
	int t = 0;
	for (int i = 0; i < a.size() || b.size(); i++) {
		if (i < a.size()) t += a[i];
		if (i < b.size()) t += b[i];
		c.push_back(t % 10);
		t /= 10;
	}
	if (t != 0) c.push_back(t % 10);
	return c;
}
```

#### 2.高精度减法
```cpp
vector<int> highSub(vector<int>& a, vector<int>& b) {
	vector<int> c;
	for (int i = 0 ,t = 0; i < a.size(); i++) {
		t = a[i] - t;
		if (i < b.size()) t -= b[i];
		c.push_back((t + 10) % 10);
		if (t < 0) t = 1;
		else t = 0;
	}
	while (c.size() > 1 && c.back() == 0) c.pop_back();
	return c;
}
```

#### 3.高精度乘法
```cpp
vector<int> highMul(vector<int>& a, vector<int>& b) {
	vector<int> c(a.size() + b.size(), 0);
	for (int i = 0; i < a.size(); i++) {
		for (int j = 0; j < b.size(); j++) {
			c[i + j - 1] += a[i] * b[j];
		}
	}
	for (int i = 0; i < c.size(); i++) {
		if (c[i] >= 10) {
			c[i + 1] += c[i] / 10;
			c[i] %= 10;
		}
	}
	while (c.size() > 1 && c.back() == 0) c.pop_back();
	return c;
}
```

#### 4.高精度除法
```cpp

void copy(vector<int>& b, vector<int>& t, int offset) {
	for (int i = 0; i < b.size(); i++) {
		t[i + offset] = b[i];
	}
}
bool comp(vector<int>& a, vector<int>& t) {
	for (int i = 0; i < a.size(); i++) {
		if (a[i] > t[i]) return true;
		else if (a[i] < t[i]) return false;
	}
	return true;
}

void sub(vector<int>& a, vector<int>& b) {
	for (int i = a.size(); i >= 0; i--) {
		if (a[i] < b[i]) {
			a[i] += 10;
			a[i - 1] -= 1;
		}
		a[i] -= b[i];
	}
}

vector<int> highDiv(vector<int>& a, vector<int>& b) {
	vector<int> c(a.size() - b.size() + 1, 0);
	vector<int> t(a.size() + b.size(), 0);
	int* t = new int[a.size() + b.size()];
	for (int i = 0; i < c.size(); i++) {
		t.assign(t.size(), 0);
		copy(b, t, i - 1);
		while (comp(a, t) == true) {
			sub(a, t);
			c[i]++;
		}
	}
	return c;
}
```

