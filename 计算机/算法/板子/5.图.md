#### 1.Kruskal(并查集) -> 最小生成树
```cpp
class UnionSet {
private:
	vector<int> ft, size;
	int n;

public:
	UnionSet(int _n) {
		n = _n;
		ft.resize(n);
		size.resize(n, 1);
		for (int i = 0; i < n; i++) {
			ft[i] = i;
		}
	}

	int find(int x) {
		// 递归终止条件：当前节点是根节点
		if (ft[x] == x) return x;

		// 递归查找根节点，并更新父节点为根节点
		ft[x] = find(ft[x]);
		return ft[x];
	}

	int unionSet(int x, int y) {
		int fx = find(x), fy = find(y);
		if (fx == fy) return false;
		if (size[fx] < size[fy]) swap(fx, fy);
		size[fx] += size[fy];
		ft[fy] = fx;
		return true;
 	}
};

struct Edge {
	int len, x, y;
	Edge(int len, int x, int y) :len(len), x(x), y(y) {};
};


class Solution {
public:
	int minCostConnectPoints(vector<vector<int>>& points) {
		int n = points.size();
		vector<Edge> edges;
		for (int i = 0; i < n;i++) {
			for (int j = i + 1; j < n; j++) {
				int len = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]);
				edges.emplace_back(len, i, j);
			}
		}

		UnionSet ust(n);
		sort(edges.begin(), edges.end(), [](Edge a, Edge b)-> bool {return a.len < b.len; });
		int ret = 0, num = 1;
		for (auto& edge : edges) {
			int len = edge.len, x = edge.x, y = edge.y;
			if (ust.unionSet(x, y)) {
				ret += len;
				num++;
				if (num == n) break;
			}
		}
		return ret;
	}
};
```

#### 2.dijkstra -> 单源最短路
leetcode 743;
```cpp
class Solution {
public:
	int networkDelayTime(vector<vector<int>>& times, int n, int k) {
		vector<vector<int>> g(n + 1, vector<int>(n + 1, INT_MAX / 2));
		for (auto& t : times) {
			g[t[0] - 1][t[1] - 1] = t[2];
		}

		vector<int> dis(n + 1, INT_MAX / 2), done(n + 1);
		dis[k] = 0;

		while (true) {
			int x = -1;
			for (int i = 1; i <= n; i++) {
				if (!done[i] && (x < 0 || dis[i] < dis[x])) {
					x = i;
				}
			}

			if (x < 0) break;
			if (dis[x] == INT_MAX / 2) break;

			done[x] = true;
			for (int y = 1; y <= n; y++)
				dis[y] = min(dis[y] , dis[x] + g[x][y]);
		}
	}
};
```

#### 3.dijkstra(堆)
```cpp
class Solution2 {
public:
	int networkDelayTime(vector<vector<int>>& times, int n, int k) {
		vector<vector<pair<int, int>>> g(n + 1);
		for (auto& t : times) {
			g[t[0]].emplace_back(t[1], t[2]);
		}

		vector<int> dis(n + 1, INT_MAX);
		dis[k] = 0;
		priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int,int>>> pq;
		pq.push({ 0, k });
		while (!pq.empty()) {
			
			auto t = pq.top();
			int dx = t.first, x = t.second;
			pq.pop();

			if (dx > dis[x]) continue;
			for (auto tmp : g[x]) {
				int y = tmp.first, dy = tmp.second;
				int newdy = dx + dy;
				if (newdy < dis[y]) {
					dis[y] = newdy;
					pq.push({ newdy,y });
				}
			}
		}
	}
};
```

#### 4.