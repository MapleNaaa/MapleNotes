1. 基于数据排序
2. 比较器
3. 排序总结

#### 1.基于数据排序
我们之前学的6个排序算法都是比较排序。二者之间可以相互进行比较。

##### 1.基数排序
我们现在来看一个排序方法，叫做计数排序。
假如我们要排列 1M 个 人的年龄
人的年龄从 1 开始，最大我就算他，150岁

那我们可以准备 150 个桶，去遍历每个元素，如果当前元素是 88，那就丢到第 88 个桶里面去。
遍历完成，也就排好序了。

他的时间复杂度 为 O(N),空间复杂度为 O(150N)

太简单了吧，主播。
而且时间复杂度极其优秀，我们之后就用这个方法吧。

不行的，现在是150个桶，那之后呢？
假如我用这个方法去排列，INT_MIN 到 INT_MAX 之间的 数，
那我岂不是要准备 超级多的桶呢？

所以此法万万不可行。
只有当数据具有一些特征，且特征较少是，可以使用。

##### 2.基数排序
基数排序是目前时间复杂度最低的排序算法。（只针对与非负数整数的情况，但也有例外，之后讨论）

我们把基数radix作为桶，radix为10，就有10个桶，radix为16，就有16个桶。

现在我们假设 radix 为 10
有一堆数，
007，109，026，710，079
我们先看个位，
7 9 6 0 9
那
7号桶：007
9号桶：109，079
6号桶：026
0号桶：710

我们按照大小先后关系，将值取出
710，026，007，109，079

再看十位，然后倒出
007 109 710 026 079

再看百位
007 026 079 109 710

这就排好序了。

这就是基数排序，从小到大的，权位依次变重。

这段代码时主播我在左神的代码上进行了修改，比快排快10倍！！！
自从主播知道了位运算比正常的加减乘除快之后，主播就开始从这上面做文章。

下面让主播逐行讲解代码
// 其中 radix 必须为 2 的整数倍

大体思路。

首先，我们知道，数都是二进制构成的。
00000100001111001  a
类似与这样。
笔者又受到之前异或代码的启发，
00000000001110000  b
a & b = (0)0111(0) 
那我么再把后面的 0 除掉，
我就获得了，当前进位上的余数(?)

就可以进行桶排序了
```
// 基数排序核心实现
static void _radixSortProcess(int* arr, int L, int R, int digit, int radix) {
	int size = R - L + 1;
	int* help = new int[size]; // 辅助数组
	int divisor = 1; // divisor
	int offset = _getbits(radix, 2) - 1; // 代表数位 32 -> 5, 2 -> 1
	int* count = new int[radix](); // 初始化，默认为 0


	for (int d = 1; d <= digit; ++d) {
		divisor = (1 << (d * offset)) - divisor; // 这是我们的关键
		memset(count, 0, radix * sizeof(int));

		// 统计每个桶的元素数量
		for (int i = L; i <= R; ++i) {
			int num = (arr[i] & divisor) >> ((d - 1) * offset); // 优化
			count[num]++;
		}

		// 计算前缀和
		for (int i = 1; i < radix; ++i) {
			count[i] += count[i - 1];
		}

		// 从右向左排序保证稳定性
		for (int i = R; i >= L; --i) {
			int num = (arr[i] & divisor) >> ((d - 1) * offset);
			help[--count[num]] = arr[i];
		}

		// 写回原数组
		for (int i = L, j = 0; i <= R; ++i, ++j) {
			arr[i] = help[j];
		}
	}
	delete[] count; // 释放当前循环的count数组
	delete[] help; // 释放辅助数组
}
```

![](https://cdn.jsdelivr.net/gh/Maple819/PicGo@main/img/20250317204721185.png)
下面数组的是上面数组的前缀和